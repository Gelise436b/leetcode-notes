# leetcode-notes
My LeetCode study notes and solutions
## 📅 学习日志
## 📚 目录（点击跳转）
- [Day 1 - 数组基础](#day-1---数组基础)
- [Day 2 - 哈希表与位运算初探](#day-2---哈希表与位运算初探)
- [Day 3 - 数组进阶与哈希表应用](#day-3---数组进阶与哈希表应用)
- [Day 4 - 矩阵操作与字符串基础](#day-4---矩阵操作与字符串基础)
- [Day 5 - 字符串处理与整数边界](#day-5---字符串处理与整数边界)
- [Day 6 - 字符串处理进阶与边界细节](#day-6---字符串处理进阶与边界细节)
- [Day 7 - 字符串收官与链表初探](#day-7---字符串收官与链表初探)
- [Day 8 - 链表核心技法突破](#day-8---链表核心技法突破)
- [Day 9 - 链表收官 & 树章节启航](#day-9---链表收官--树章节启航)
- [Day 10 - 树专题攻坚 & 遍历思维深化](#day-10---树专题攻坚--遍历思维深化)
- [Day 11 - 树专题完结和排序搜索完结](#day-11---树专题完结和排序搜索完结)
- [Day 12 - 动态规划启程：从状态定义到最优子结构](#day-12---动态规划启程从状态定义到最优子结构)
- [Day 13 - 动态规划收官与设计问题初探：从状态建模到工程封装](#day-13---动态规划收官与设计问题初探从状态建模到工程封装)
- [Day 14 - 数学专题初探：从规则模拟到数论性质与算法优化](#day-14---数学专题初探从规则模拟到数论性质与算法优化)
- [Day 15 - 位运算初探：从进制解析到二进制操作的范式跃迁](#day-15---位运算初探从进制解析到二进制操作的范式跃迁)
  
### Day 1 - 数组基础
- **完成题目**：
  - [x] [26] 删除有序数组中的重复项  
  - [x] [189] 轮转数组  
  - [ ] [122] 买卖股票的最佳时机 II ❌（未独立完成）
- **学习重点**：
  - 掌握双指针原地去重（题 26）
  - 理解数组轮转的**三次反转技巧**（题 189）
- **卡点反思**：
  - 题 [122] 卡在“如何多次买卖求最大利润”，**未能想到贪心策略**。
  - 初次接触贪心算法，不理解“为什么每天上涨都交易能得到全局最优”。
  - 误以为需要记录买入点，陷入复杂状态判断，忽略了**利润可拆分为所有正差价之和**的本质。
- **收获与改进**：
  - 通过题解理解了贪心的核心：**局部最优（每天赚就卖） ⇒ 全局最优（总利润最大）**
  - 已整理详细笔记（见 [买卖股票的最佳时机 II](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.md)）
- **明日计划**：
  - 手写 [122] 的 C++ 实现，默写一遍
  - 开始 Day 2：（217, 136, 350）

---


### Day 2 - 哈希表与位运算初探  
- **完成题目**：  
  - [x] [217] 存在重复元素  
  - [x] [136] 只出现一次的数字  
  - [x] [350] 两个数组的交集 II  

- **学习重点**：  
  - 掌握使用 `unordered_set` 判断元素是否存在（题 217）  
  - 理解**异或运算的性质**：`a ^ a = 0`，`a ^ 0 = a`，满足交换律与结合律（题 136）  
  - 回顾哈希表（`unordered_map`）统计频次并求交集的方法（题 350）  

- **卡点反思**：  
  - 题 [217] 中对 C++ `set` / `unordered_set` 的基本操作（如 `insert()`、`count()`）记忆模糊，导致编码迟疑。  
  - 题 [350] 本想用哈希表高效求解，但一时忘记如何用 `map` 统计频次并处理重复元素，退而使用了排序+双指针（虽可行但非最优复习目标）。  
  - 题 [136] 虽独立完成（使用 set 或 map），但**未主动想到异或解法**，说明对位运算的敏感度不足。  

- **收获与改进**：  
  - 深刻体会到**异或运算是解决“唯一出现”类问题的利器**，简洁且 O(1) 空间。  
  - 意识到 STL 容器（尤其是 `unordered_set` 和 `unordered_map`）的常用接口需要定期巩固。  
  - 已整理笔记：([存在重复元素](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md)),([只出现一次的数字](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md))

- **明日计划**：  
  - 完成新题：[344] 反转字符串、[151] 反转字符串中的单词、[88] 合并两个有序数组  
  - 复习今日三题（217, 136, 350），重点手写哈希表与异或解法  
  - 补充复习 C++ `unordered_set` / `unordered_map` 常用方法  

---

### Day 3 - 数组进阶与哈希表应用  
- **完成题目**：  
  - [x] [66] 加一  
  - [x] [283] 移动零  
  - [x] [1] 两数之和  

- **学习重点**：  
  - 理解数组末尾“进位”处理的边界情况（题 66）  
  - 掌握**双指针原地移动元素**的思想，实现非零元素前移、零元素后置（题 283）  
  - 熟悉使用 `unordered_map` 实现“值 → 下标”的快速映射，解决配对问题（题 1）  

- **卡点反思**：  
  - 题 [66] 在处理连续 9 的进位时逻辑混乱，**未清晰拆解“从后往前遍历 + 进位标志”** 的流程，导致边界（如 `[9,9,9] → [1,0,0,0]`）处理失败。  
  - 题 [283] 虽知道要用双指针，但混淆了快慢指针的职责：**慢指针应指向下一个非零元素应放置的位置**，而非简单交换。初期尝试用额外数组，违背了“原地操作”要求。  
  - 题 [1] 虽知道可用哈希表，但对 `map.count(target - num)` 判断是否存在、以及何时插入当前元素存在犹豫，**未能形成“先查后插”的标准流程**，担心重复或顺序问题。  

- **收获与改进**：  
  - 明白了数组模拟加法的核心是**逆序遍历 + 进位传播**，若全程无中断进位，则需在头部补 1。  
  - 掌握了“快指针扫描、慢指针写入”的双指针模板，适用于**过滤/移动特定元素**类问题。  
  - 巩固了哈希表在“两数之和”类问题中的标准解法：**遍历时先检查 complement 是否存在，不存在再将当前元素加入 map**，避免自身重复使用。  
  - 已整理笔记：([加一](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8A%A0%E4%B8%80.md))、([移动零](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E7%A7%BB%E5%8A%A8%E9%9B%B6.md))、([两数之和](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md))

- **明日计划**：  
  - 手写三题（66, 283, 1）的 C++ 实现，重点默写双指针与哈希表逻辑  
  - 复习今日错点：进位边界、快慢指针分工、map 查询与插入时机  
  - 开始 Day 4：（36.有效的数独、48.旋转图像、344.反转字符串）  

--- 
### Day 4 - 矩阵操作与字符串基础  
- **完成题目**：  
  - [x] [36] 有效的数独  
  - [x] [48] 旋转图像  
  - [x] [344] 反转字符串  

- **学习重点**：  
  - 掌握利用**三维布尔数组**或**哈希集合**对数独的行、列、3×3 宫格进行独立校验（题 36）  
  - 理解矩阵**顺时针旋转 90° 的两步法**：先转置（transpose），再逐行反转（题 48）  
  - 熟悉字符串原地反转的**双指针交换**模板，首尾相向移动直至相遇（题 344）  

- **卡点反思**：  
  - 题 [36] 能想到用 `row_has[i][num]` 和 `col_has[j][num]` 分别记录行和列的数字出现情况，但**卡在如何标识 3×3 宫格**。起初试图用复杂条件判断所属宫格，未意识到 `(i/3, j/3)` 可自然将 9×9 划分为 3×3 的块坐标，导致无法统一建模。  
  - 题 [48] 完全**缺乏旋转的几何直觉**，尝试直接推导新旧坐标映射关系失败，也未联想到“转置 + 反转”这一经典组合技巧，陷入硬编码坐标的误区。  
  - 题 [344] 实现顺利，但初期担心 `char` 类型交换是否需特殊处理，实则 C++ 中 `swap` 对字符完全适用，属于不必要的犹豫。  

- **收获与改进**：  
  - 明白了数独中 **3×3 子网格的索引可通过 `i/3` 和 `j/3` 整除压缩**，从而用 `sub_box[3][3][9]` 精准定位每个宫格的状态，实现 O(1) 校验。  
  - 掌握了**矩阵旋转的通用思维**：不直接硬算，而是拆解为基本操作（如转置、翻转）的组合，极大降低实现难度。  
  - 巩固了字符串原地操作的双指针模式，确认其适用于所有“对称交换”类问题，代码简洁且空间最优。  
  - **今日正式完成 LeetCode 初级算法《数组》章节全部内容**，建立起对数组边界处理、原地操作、哈希映射及矩阵变换的基本解题框架。  
  - 已整理笔记：([有效的数独](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC.md))、([旋转图像](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F.md))、
- **明日计划**：  
  - 手写三题（36, 48, 344）的 C++ 实现，重点默写宫格索引计算、矩阵转置+反转流程、字符串双指针交换  
  - 复习今日核心技巧：`i/3, j/3` 宫格划分、矩阵旋转的两步法、原地反转模板  
  - 开始 Day 5：继续 LeetCode 初级算法 —— 字符串专题（7.整数反转、387. 字符串中的第一个唯一字符、242. 有效的字母异位词、）
### Day 5 - 字符串处理与整数边界  
- **完成题目**：  
  - [x] [7] 整数反转  
  - [x] [387] 字符串中的第一个唯一字符  
  - [x] [242] 有效的字母异位词  

- **学习重点**：  
  - 掌握**整数反转时的溢出判断技巧**（题 7）：在每次更新结果前，通过 `res > INT_MAX / 10` 或 `res < INT_MIN / 10` 预判是否越界，避免直接计算导致未定义行为。  
  - 学会使用 **`unordered_map` + `string::find()` 结合迭代器比较** 的方式定位唯一字符（题 387），理解 `s.find(c) == s.rfind(c)` 或 `map.count(c) == 1 && first_occurrence == last_occurrence` 等等价思路。  
  - 理解**字母异位词（Anagram）** 的定义：两个字符串包含**完全相同的字符及其频次**，仅顺序不同（如 "listen" 与 "silent"）。验证方法通常为**字符频次统计**或**排序后比较**（题 242）。  

- **卡点反思**：  
  - 题 [242] 虽能写出正确代码（如用哈希表统计频次），但**初始不理解“字母异位词”的确切含义**，反映出对基础术语掌握不足，影响问题建模速度。  
  - 题 [387] 最初仅想到两次遍历计数+再遍历找首个频次为1的字符，**未意识到可利用 `find` 与 `rfind` 返回位置是否相等来直接判断唯一性**，新方法更简洁且无需额外存储频次。  
  - 题 [7] 在处理负数和末尾零时逻辑稍显混乱，初期未统一用 `long` 或提前截断，导致边界测试用例（如 `1534236469`）失败。  

- **收获与改进**：  
  - 明确了**字母异位词 = 字符组成完全一致（频次相同）**，今后遇到类似描述可快速联想到频次哈希或排序策略。  
  - 掌握了**利用字符串查找函数判断字符唯一性**的新技巧：若 `s.find(c) == s.rfind(c)`，说明该字符仅出现一次，适用于首个唯一字符类问题。  
  - 巩固了**整数操作中的防溢出意识**，学会在循环体内做“预检查”而非事后判断，提升代码鲁棒性。  
  - 初步建立起字符串问题的两大核心思路：**频次统计（哈希）** 与 **顺序无关化（排序）**，为后续字符串专题打下基础。  

- **明日计划**：  
  - 手写三题（7, 387, 242）的 C++ 实现，重点默写溢出判断条件、`find/rfind` 唯一性判断、异位词的哈希/排序两种解法  
  - 复习今日核心概念：字母异位词定义、整数反转防溢出模板、字符串唯一字符的多种判定方式  
  - 开始 Day 6：继续 LeetCode 初级算法 —— 字符串专题（125. 验证回文串、88. 字符串转换整数、28.找出字符串中第一个匹配的下标）

---

### Day 6 - 字符串处理进阶与边界细节  
- **完成题目**：  
  - [x] [125] 验证回文串  
  - [x] [8] 字符串转换整数（atoi）  
  - [x] [28] 找出字符串中第一个匹配项的下标  

- **学习重点**：  
  - 掌握**回文串验证的标准处理流程**（题 125）：忽略非字母数字字符、统一大小写后使用双指针比对。关键工具函数 `isalnum()` 可高效判断字符是否为字母或数字，避免手动枚举字符范围。  
  - 理解 **`atoi` 实现中的状态机思维**（题 8）：依次处理前导空格 → 符号位 → 数字部分 → 溢出截断。需注意不能依赖 `isdigit` 或 `isalnum` 过度简化逻辑，而应严格按题意分阶段解析。  
  - 初步接触**字符串匹配的两种策略**（题 28）：  
    - 简洁解法：直接调用 `haystack.find(needle)`；  
    - 高效解法：KMP 算法（当前尚未掌握，需后续专项学习）。  

- **卡点反思**：  
  - 题 [125] **未第一时间想到使用 `isalnum()`**，试图手动判断 `'a'-'z'`、`'A'-'Z'`、`'0'-'9'`，导致代码冗长且易漏边界（如大写转小写不彻底），反映出对 C++ 标准库字符处理函数不熟悉。  
  - 题 [8] 在解析数字时**错误尝试用 `isalnum` 辅助判断**，混淆了“字母数字”与“纯数字”的区别（例如 `'a'` 是 alnum 但不是 digit），导致逻辑混乱。正确做法应使用 `isdigit` 或直接比较 `'0' <= c <= '9'`。  
  - 题 [28] **完全依赖 `find()` 取巧通过**，对 KMP 算法原理一无所知，暴露出在“不调库”场景下的算法能力短板，尤其在面试要求手写匹配逻辑时会陷入被动。  

- **收获与改进**：  
  - 明确了 **C++ 字符分类函数的适用场景**：  
    - `isalnum(c)`：判断是否为字母或数字（用于回文过滤）；  
    - `isdigit(c)`：仅判断是否为数字（用于 atoi 解析）；  
    - `tolower(c)/toupper(c)`：安全进行大小写转换。  
  - 意识到 **复杂字符串解析题需分阶段建模**（如 atoi 的“跳空格→读符号→累加数字→防溢出”四步），避免试图一步到位。  
  - 认清了 **KMP 是字符串匹配的核心算法之一**，虽可暂时用库函数过关，但必须列入后续重点攻克清单。
  - 已整理笔记([验证回文串](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.md)),([字符串转换整数](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0.md)),([找出字符串中第一个匹配的下标项](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.md))

- **明日计划**：  
  - **手写重做今日三题（125, 8, 28）**，重点练习：  
    - 使用 `isalnum + tolower` 实现干净的回文判断；  
    - 不依赖任何转换函数，手动实现 atoi 的完整状态逻辑；  
    - 尝试写出暴力版 strStr（双层循环），并初步阅读 KMP 原理。  
  - **推进 LeetCode 初级算法新题**：  
    - [38] 外观数列  
    - [14] 最长公共前缀  
    - [237] 删除链表中的节点（注意：此题为“伪删除”，仅给定待删节点指针）  
  - 复习字符处理标准库函数，整理常用 API 速查表。

---
### Day 7 - 字符串收官与链表初探  
- **完成题目**：  
  - [x] [38] 外观数列  
  - [x] [14] 最长公共前缀（至此完成 LeetCode 初级算法 · 字符串全部题目）  
  - [x] [237] 删除链表中的节点  

- **学习重点**：  
  - 掌握**外观数列的递归建模思路**（题 38）：理解 `countAndSay(n)` 依赖于 `countAndSay(n-1)` 的返回结果，将问题拆解为“先拿到上一层描述字符串，再对其进行连续字符计数与拼接”。关键在于接受递归的“黑盒”思想——不必深究每层调用细节，只需相信前一层能正确返回所需字符串。  
  - 熟悉**最长公共前缀的矩阵视角**（题 14）：将字符串数组视为字符矩阵，逐列比对所有行在该列的字符是否一致。一旦某列出现不匹配或到达某字符串末尾，即终止并返回当前前缀。这种“垂直扫描”策略简洁高效，优于横向两两比较。  
  - 理解**链表“伪删除”的实现本质**（题 237）：题目仅提供待删节点指针，无法访问前驱。解决方案是**将下一节点的内容拷贝到当前节点**，再跳过下一节点。核心操作为 `*node = *(node->next)`（C++）或等价的字段赋值（如 `val` 和 `next` 分别覆盖），而非简单移动指针。  

- **卡点反思**：  
  - 题 [38] **递归思维未建立**：卡在无法想象 `string previous = countAndSay(n - 1)` 的具体返回形态，导致无法在此基础上进行字符遍历与计数拼接。反映出对递归“自顶向下分解、自底向上构建”的过程缺乏直觉。  
  - 题 [14] **缺乏结构化视角**：未将字符串数组抽象为二维字符矩阵，执着于逐字符串两两求交集，逻辑复杂且易错。未能第一时间想到“按列统一检查”这一更优策略。  
  - 题 [237] **混淆指针与解引用语义**：错误地写成 `node = node->next`，这只是局部指针变量重定向，并未修改原链表结构；正确做法需通过 `*node = *(node->next)` 覆盖当前节点内容（或分别赋值 `val` 和 `next`），真正实现“值覆盖式删除”。  

- **收获与改进**：  
  - 明确了**递归函数设计的关键信任原则**：只要 base case 正确、递推关系清晰，就应相信子调用能返回正确结果，专注当前层的处理逻辑。  
  - 强化了**多字符串处理的“矩阵化”思维**：对于涉及多个等长/变长字符串的公共操作（如前缀、列对齐），尝试将其视为二维结构，常能简化问题。  
  - 深刻认识到**链表操作中“修改节点内容”与“修改指针指向”的区别**：尤其在受限条件下（如无前驱指针），需灵活运用值拷贝实现逻辑删除。  
  - 已完成 LeetCode 初级算法 · 字符串模块全部内容，标志着字符串基础处理能力初步成型。
  - 已整理笔记([外观数列](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97.md)),([最长公共前缀](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.md))([删除链表中的节点](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md))

- **明日计划**：  
  - **复习今日三题（38, 14, 237）**，重点练习：  
    - 手写外观数列的迭代与递归两种实现，强化递归建模能力；  
    - 实现最长公共前缀的“垂直扫描”法，并对比横向方法的差异；  
    - 重做 237 题，确保理解 `*node = *(node->next)` 的内存含义。  
  - **回顾 Day 6 的 KMP 相关内容**：重读 [28] 题笔记，尝试手写暴力版 `strStr`，并初步理解 KMP 的 next 数组思想。  
  - **推进 LeetCode 初级算法 · 链表部分**：  
    - [19] 删除链表的倒数第 N 个节点  
    - [206] 反转链表  
    - [21] 合并两个有序链表
    - 
### Day 8 - 链表核心技法突破  
- **完成题目**：  
  - [x] [19] 删除链表的倒数第 N 个节点  
  - [x] [206] 反转链表  
  - [x] [21] 合并两个有序链表  

- **学习重点**：  
  - 掌握**快慢指针在链表中的通用模式**（题 19）：通过让快指针先走 `N` 步，再同步移动快慢指针，使慢指针最终停在待删节点的前驱位置。关键在于理解“距离差恒定”这一思想——快慢指针间距始终为 `N`，当快指针到达末尾时，慢指针自然指向倒数第 `N+1` 个节点。此技巧是处理“倒数第 K 个”类问题的标准解法。  
  - 熟悉**链表反转的迭代实现逻辑**（题 206）：采用头插法思想，遍历原链表并将每个节点插入到新链表的头部。核心三步操作：保存下一节点（`next = cur->next`）、当前节点指向前驱（`cur->next = prev`）、更新前驱与当前指针（`prev = cur; cur = next`）。避免陷入递归细节，优先掌握清晰可控的迭代写法。  
  - 理解**有序链表合并的“尾接剩余”策略**（题 21）：在双指针遍历结束后，必有一个链表非空。无需复杂判断，直接使用 `cur->next = list1 ? list1 : list2;` 即可将剩余有序部分整体接入结果链表末尾，简洁且高效。  

- **卡点反思**：  
  - 题 [19] **快慢指针迁移能力不足**：虽在数组/字符串中熟练使用双指针，但面对链表指针操作时未能及时联想。反映出对“指针即位置”的抽象理解不够——链表中的指针本质仍是位置标识，快慢指针的相对距离思想完全适用。  
  - 题 [206] **基础操作记忆模糊**：遗忘头插法的核心步骤，试图用复杂逻辑重构反转过程，导致代码混乱。说明对链表基本操作（如头插、尾插）缺乏肌肉记忆，需回归基础手法训练。  
  - 题 [21] **过度复杂化边界处理**：在循环结束后纠结于“如何判断哪个链表为空”，试图分别检查 `list1` 和 `list2`，忽略了三元运算符 `?:` 的简洁表达力。暴露出对 C++ 条件表达式的灵活运用不熟练。  

- **收获与改进**：  
  - 明确了**快慢指针是跨数据结构的通用技巧**：无论数组索引还是链表指针，只要涉及“相对位置”或“延迟访问”，均可考虑双指针策略。  
  - 重建了**链表基本操作的直觉**：头插法、尾插法、指针重连等是链表题的原子操作，必须像背乘法表一样熟练。  
  - 强化了**简洁边界处理意识**：对于“剩余部分拼接”类问题，善用 `a ? a : b` 或 `if (a) p->next = a; else p->next = b;` 可大幅简化逻辑。  
  - 已系统覆盖 LeetCode 初级算法 · 链表模块的核心题型（删除、反转、合并），为后续复杂链表问题打下坚实基础。
  - 已整理笔记:([删除链表的倒数第n个节点](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9.md)),([反转链表](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md)),([合并两个有序链表](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md))

- **明日计划**：  
  - **复习今日三题（19, 206, 21）**，重点练习：  
    - 手写快慢指针删除倒数第 N 节点的完整代码，确保 dummy 节点与指针移动逻辑无误；  
    - 默写反转链表的迭代版本，强化“保存下一节点 → 反转指针 → 更新状态”三步流程；  
    - 实现合并链表的两种写法（显式 if-else 与三元运算符），体会简洁性差异。  
  - **完成 LeetCode 初级算法 · 链表剩余题目**：  
    - [234] 回文链表  
    - [141] 环形链表  
  - **开启新章节 · 树**：  
    - [104] 二叉树的最大深度（初步接触树的递归遍历思想）

  ### Day 9 - 链表收官 & 树章节启航  
- **完成题目**：  
  - [x] [234] 回文链表  
  - [x] [141] 环形链表  
  - [x] [104] 二叉树的最大深度  

- **学习重点**：  
  - 掌握**回文链表的“快慢指针 + 局部反转”组合技法**（题 234）：先用快慢指针定位链表中点，再将后半部分原地反转，最后双指针从头与中点向两侧同步比对。该解法空间复杂度 O(1)，是处理链表回文问题的最优策略，体现了“分阶段操作链表”的高阶思维。  
  - 巩固**环形检测的 Floyd 判圈算法**（题 141）：快指针每次走两步，慢指针每次走一步，若存在环则二者必在环内相遇。此方法无需额外空间，逻辑简洁且鲁棒性强，已成为判断链表/序列是否存在循环的标准范式。  
  - 初识**树的两种遍历范式**（题 104）：  
    - **DFS（递归后序）**：自然契合“子问题分解”思想，代码简洁；  
    - **BFS（层序迭代）**：通过队列逐层推进，直观体现“按层计数”逻辑。  
    二者分别对应“深度”与“广度”的核心抽象，是后续所有树问题的基石。  

- **卡点反思**：  
  - 题 [234] **模块化思维缺失**：虽已掌握快慢指针（Day 8 题 19）和链表反转（Day 8 题 206），但未能主动将二者**组合应用**于新场景。反映出对“算法组件复用”意识薄弱——应视快慢指针、反转、合并等为可拼装的“工具块”，而非孤立技巧。  
  - 题 [104] **基础算法记忆断层**：面对简单树题竟遗忘 DFS/BFS 的标准实现，暴露出对数据结构核心遍历模式缺乏系统性巩固。说明前期学习偏重“做题”而忽视“框架梳理”，导致知识碎片化。  
  - 整体**跨章节迁移能力待提升**：链表与树虽结构不同，但指针操作、递归思想、双指针策略高度相通，需建立“数据结构共性认知”。  

- **收获与改进**：  
  - **正式完成 LeetCode 初级算法 · 链表全章**，建立起“指针操作 → 算法组合 → 空间优化”的完整解题链条；  
  - **成功开启树章节**，初步感知递归与层序遍历的双重威力，明确树问题“自顶向下”与“自底向上”的思考路径；  
  - 意识到**算法不是孤立技巧，而是可组合的积木**：快慢指针+反转=回文检测，递归+max=最大深度，未来需强化“识别子问题 → 调用已有模块”的能力；  
  - 重新锚定**基础遍历算法的核心地位**：DFS/BFS 不仅是树的基础，更是图论、状态搜索等问题的起点，必须形成肌肉记忆。
  - 已整理笔记([回文链表](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.md)),([二叉树的最大深度](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.md))

- **明日计划**：  
  - **重点复习今日薄弱环节**：  
    - 手写 [234] 回文链表完整代码，确保“找中点 → 反转后半段 → 双指针比对 → （可选）恢复链表”四步流程无误；  
    - 默写 [104] 的 DFS 与 BFS 两种解法，强化树遍历模板记忆；  
  - **推进树章节核心题型**：  
    - [98] 验证二叉搜索树（BST 性质 + 中序遍历单调性）  
    - [101] 对称二叉树（递归镜像比对 / BFS 双端队列）  
    - [102] 二叉树的层序遍历（BFS 标准模板深化）  
  - **建立树问题分类意识**：按“遍历类”、“验证类”、“构造类”初步归类，构建解题策略地图。
    
 ### Day 10 - 树专题攻坚 & 遍历思维深化  
- **完成题目**：  
  - [x] [98] 验证二叉搜索树  
  - [x] [101] 对称二叉树  
  - [x] [102] 二叉树的层序遍历  
  - [x] 复习 [234] 回文链表、[104] 二叉树的最大深度  

- **学习重点**：  
  - **掌握 BST 验证的中序遍历核心思想**（题 98）：BST 的中序遍历必为严格递增序列。通过全局前驱值 `pre` 在递归中实时校验单调性，实现 O(n) 时间、O(h) 空间的优雅解法。此题再次印证“树的性质 ⇨ 遍历顺序”的映射关系——**选对遍历方式，问题迎刃而解**。  
  - **深化“镜像对称”的递归建模能力**（题 101）：对称 ≠ 左右子树结构相同，而是 **左子树的左 ↔ 右子树的右** 且 **左子树的右 ↔ 右子树的左** 同时成立。该题训练了“双指针同步递归”的思维模式，是处理树结构关系类问题的关键范式。  
  - **巩固层序遍历的 BFS 实现逻辑**（题 102）：通过维护当前层节点列表（或队列），逐层收集值并生成下一层节点，清晰体现“广度优先”的层次推进特性。使用双数组（`que` 与 `tmp`）虽非最简，但逻辑直观，适合初学阶段建立空间分层认知。  

- **卡点反思**：  
  - 题 [98] **遍历方式混淆与递归过度复杂化**：初期纠结于前/中/后序的选择，试图用前序传递边界却陷入细节；后意识到中序天然契合“单调性”验证，只需专注 **边界条件（空节点） + 当前节点与前驱比较** 两大要素。反映出对“遍历本质目的”理解不足——**遍历是手段，性质验证才是目标**。  
  - 题 [101] **对称定义理解片面**：仅检查左右子树根节点相等，忽略了子树间的交叉对应关系（左-右 vs 右-左）。暴露出对“结构对称”缺乏空间想象，未能将问题转化为 **两棵树互为镜像** 的标准模型。  
  - 整体**基础遍历模板熟练度仍不足**：面对新题仍需回忆遍历顺序定义，说明 DFS/BFS 尚未形成条件反射。需通过高频默写固化“递归三要素”与“BFS 层控技巧”。  

- **收获与改进**：  
  - **系统串联树遍历与问题性质**：明确中序 → BST 单调性、后序 → 自底向上计算、BFS → 层级操作的对应关系，初步建立“问题特征 → 遍历策略”的决策链；  
  - **强化递归的“黑盒思维”**：在 [98][101] 中实践“只关注当前层逻辑，子问题交给递归”的原则，减少对调用栈的过度追踪，提升编码效率；  
  - **验证类树题解题框架初成**：  
    - BST 验证 → 中序单调性 / 前序区间约束；  
    - 对称验证 → 双指针镜像递归；  
    - 层序输出 → BFS 分层收集；  
  - **认识到“边界即答案”**：树问题的正确性往往由空节点、单节点等边界条件决定，未来需优先设计边界处理逻辑，再扩展一般情况。
  - 已整理笔记([验证二叉搜索树](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md)),([对称二叉树](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md))

- **明日计划**：  
  - **收尾树专题**：  
    - 完成 [108] 将有序数组转换为二叉搜索树（利用中序特性 + 二分构造）；  
    - **彻底复习今日三题**：手写 [98][101][102] 的 DFS/BFS 双解法，确保边界条件无遗漏；  
  - **开启排序与搜索专题**：  
    - [88] 合并两个有序数组（双指针原地合并技巧）；  
    - [278] 第一个错误的版本（经典二分查找边界应用）；  
  - **构建专题过渡意识**：树依赖指针与递归，排序/搜索侧重数组与迭代，需主动切换思维模式，同时识别共性（如二分与 BST 的内在关联）。
 
 ### Day 11 - 树专题完结和排序搜索完结
- **完成题目**：  
  - [x] [108] 将有序数组转换为二叉搜索树  
  - [x] [88] 合并两个有序数组  
  - [x] [278] 第一个错误的版本  

- **学习重点**：  
  - **掌握“分治 + 递归”构造 BST 的核心逻辑**（题 108）：有序数组天然对应 BST 的中序遍历序列，因此**取中点为根、左右子数组递归构建子树**即可保证高度平衡。关键在于理解“闭区间划分”与“递归基”的设计——当 `left > right` 时返回 `nullptr`，避免越界；中点计算采用 `mid = left + (right - left) / 2` 防溢出且精准分割。此题打通了“数组结构 ⇨ 树形结构”的映射通道，凸显分治思想在构造类问题中的威力。  
  - **深化“原地合并”的双指针逆向思维**（题 88）：面对需将 `nums2` 合并至 `nums1` 且不使用额外空间的要求，正向遍历会覆盖未处理数据，而**从后往前填充**（`p1 = m-1, p2 = n-1, p = m+n-1`）可安全利用 `nums1` 末尾预留空间。该技巧揭示了“空间复用”场景下指针方向选择的重要性——**逆序操作保全原始信息**，是数组原地算法的经典范式。  
  - **建立“二分查找”在边界判定问题中的条件反射**（题 278）：面对单调性（好版本 → 坏版本）与“第一个满足条件”的目标，应立即识别为**左边界二分模型**。通过 `while (left < right)` 循环 + `mid = left + (right - left) / 2` + “坏则保留 mid，好则跳过 mid” 的收缩策略，高效定位首个坏版本。此题标志着从线性暴力到对数优化的思维跃迁。  

- **卡点反思**：  
  - 题 [108] **递归结构建模能力不足**：虽意识到需取中点，但未能将“数组区间”抽象为递归参数，纠结于如何传递子数组（试图切片），忽略了**用索引范围代替实际切割**的轻量级递归设计。反映出对“递归状态表示”的经验欠缺——**子问题 = 原问题 + 更小的输入范围**。  
  - 题 [88] **空间约束下的算法变通意识薄弱**：第一反应是新建数组排序再拷贝，未深入思考题目给出的 `nums1` 长度为 `m+n` 的深意。暴露出对“原地操作”典型场景（如合并、去重）缺乏敏感度，未能主动联想“逆向双指针”这一高频技巧。  
  - 题 [278] **算法复杂度敏感度缺失**：直接采用 O(n) 暴力扫描，在 `n` 极大时必然超时。根本原因是对“有序 + 查找”组合缺乏警觉——**只要数据有序，优先考虑二分** 应成为本能，而非事后补救。  

- **收获与改进**：  
  - **完成树专题闭环，建立构造/验证/遍历三维认知**：  
    - 构造（[108]）→ 分治递归 + 中点选取；  
    - 验证（[98]）→ 中序单调性 / 区间约束；  
    - 遍历（[101][102]）→ DFS 对称建模 / BFS 分层控制；  
  - **开启排序/搜索专题，初识“指针艺术”与“二分哲学”**：  
    - 双指针不仅是同向快慢，更是**逆向协同的空间管理者**（[88]）；  
    - 二分查找不仅是找值，更是**边界判定的精密手术刀**（[278]）；  
  - **强化“问题特征 → 算法范式”的映射能力**：  
    - 有序数组 → 二分 / 双指针；  
    - 原地修改 → 逆向操作防覆盖；  
    - 构造平衡树 → 中点分治；  
  - **认识到“简洁即高效”**：最优解往往规避冗余操作（如数组拷贝、线性扫描），未来需优先评估时间/空间复杂度，再动手编码。
  - 已整理笔记([将有序数组转换为二叉搜索树](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md)),([合并两个有序数组](https://github.com/Gelise436b/leetcode-notes/blob/main/Sorting%26earching/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.md)),([第一个错误的版本](https://github.com/Gelise436b/leetcode-notes/blob/main/Sorting%26earching/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.md))

- **明日计划**：  
  - **巩固今日三题**：  
    - 手写 [108] 的递归构造（闭区间版）与 [88] 的逆向双指针实现；  
    - 默写 [278] 的左边界二分模板，确保循环不变式清晰；  
  - **开启动态规划专题**：  
    - [70] 爬楼梯（理解状态转移方程与斐波那契本质）；  
    - [121] 买卖股票的最佳时机（掌握“历史最小值 + 当前利润”贪心视角）；  
    - [53] 最大子序和（ Kadane 算法与 DP 状态定义）；  
  - **构建专题衔接意识**：排序/搜索侧重“确定性路径”（指针移动、区间收缩），动态规划则关注“状态演化”，需切换至“子问题依赖”思维，同时注意贪心与 DP 的边界（如股票问题）。

 
 ### Day 12 - 动态规划启程：从状态定义到最优子结构
- **完成题目**：  
  - [x] [70] 爬楼梯  
  - [x] [121] 买卖股票的最佳时机  
  - [x] [53] 最大子数组和  

- **学习重点**：  
  - **建立“状态即答案”的 DP 建模直觉**（题 [70]）：将“爬到第 `i` 阶的方法数”直接定义为状态 `dp[i]`，自然导出转移方程 `dp[i] = dp[i-1] + dp[i-2]`。通过对比**递归+记忆化**（Top-down）、**递推填表**（Bottom-up）与**滚动变量空间优化**三种实现，深刻体会到：**DP 的本质是消除重复子问题，而空间优化是对状态依赖关系的极致利用**。此题虽简单，却是理解“无后效性”与“最优子结构”的理想入口。  
  - **破除“过程执念”，聚焦“极值构造”**（题 [121]）：初始误以为需枚举所有买入/卖出日期对，实则最大利润仅由“历史最低价”与“当前价格”决定。关键洞察在于：**利润 = 当前价 - 历史最小成本**，因此只需一次遍历维护 `minPrice` 并实时更新 `maxProfit`。这揭示了贪心策略在特定 DP 问题中的等价性——当子问题最优解可由局部极值直接导出时，无需完整状态表。  
  - **识别“连续性约束”下的子问题边界**（题 [53]）：未意识到“最大子数组和”要求元素连续，导致错误尝试全局组合。正确思路是定义 `dp[i]` 为“以 `nums[i]` 结尾的最大子数组和”，从而强制连续性，并通过 `dp[i] = max(nums[i], dp[i-1] + nums[i])` 决定是否“继承前缀”。该模型凸显 DP 中**状态设计必须包含问题约束**，而最终答案需在所有子问题解中取最大值（`max(dp[0..n-1])`），而非仅 `dp[n-1]`。  

- **卡点反思**：  
  - 题 [121] **混淆了“决策变量”与“目标函数”**：过度关注“哪天买、哪天卖”的具体操作，忽略了利润仅取决于价格差这一数学本质。反映出对“问题抽象层级”把握不足——**算法应作用于数值关系，而非操作序列**。  
  - 题 [53] **忽视子问题的“结尾限定”**：试图定义 `dp[i]` 为“前 `i` 个元素的最大子数组和”，却无法处理不连续跳跃的情况。根本原因是对“连续子数组”这一约束缺乏建模意识，未能将状态与数组位置强绑定，导致转移逻辑断裂。  
  - 整体 **DP 思维仍偏“被动接受”而非“主动构造”**：面对新题时，习惯等待“标准模板”浮现，而非从“最后一步做什么”反推状态定义。这说明尚未形成“问题 → 子问题 → 状态 → 转移”的正向构建链。  

- **收获与改进**：  
  - **初步构建动态规划三要素认知框架**：  
    - **状态定义**：明确“dp[i] 代表什么”（需包含约束与目标）；  
    - **转移方程**：思考“如何由更小规模子问题推出当前解”；  
    - **边界与答案**：确定初始值及最终结果的提取方式（未必是最后一个状态）；  
  - **辨明贪心与 DP 的适用边界**：  
    - 贪心适用于**局部最优可直接导出全局最优**的场景（如 [121] 的单次交易）；  
    - DP 适用于**当前决策依赖历史路径**或**存在多阶段选择**的问题（如 [53] 的连续性约束、[70] 的路径计数）；  
  - **强化“空间即状态依赖”的优化意识**：  
    - 若状态仅依赖前 k 项（如 [70] 依赖前两项），可用滚动变量将空间压至 O(1)；  
    - 此技巧不仅节省内存，更反向验证了状态设计的简洁性；  
  - **认识到“简单题是思想的浓缩”**：[70][121][53] 均无复杂数据结构，却分别承载了**计数型 DP、贪心特例、序列型 DP** 的核心范式，未来需以“解剖麻雀”心态精读每道入门题。
  - 已整理笔记([爬楼梯](https://github.com/Gelise436b/leetcode-notes/blob/main/DynamicProgram/%E7%88%AC%E6%A5%BC%E6%A2%AF.md)),([买卖股票的最佳时机](https://github.com/Gelise436b/leetcode-notes/blob/main/DynamicProgram/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.md)),([最大子数组和](https://github.com/Gelise436b/leetcode-notes/blob/main/DynamicProgram/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.md))

- **明日计划**：  
  - **巩固今日三题**：  
    - 手写 [70] 的三种实现（记忆化递归 / 迭代 DP / 滚动变量）；  
    - 默写 [121] 的贪心逻辑与 [53] 的 Kadane 算法，确保状态定义精准；  
  - **完成动态规划收尾**：  
    - [198] 打家劫舍（掌握“相邻互斥”约束下的状态转移：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`）；  
  - **开设计问题专题**：  
    - [384] 打乱数组（理解 Fisher-Yates 洗牌算法的均匀性与原地性）；  
    - [155] 最小栈（设计辅助栈维护历史最小值，实现 O(1) 查询）；  
  - **构建专题衔接意识**：动态规划强调“状态演化”，设计问题则侧重“接口封装”与“时空权衡”，需切换至“工程实现”视角，关注 API 设计、随机性保证、操作复杂度等新维度。

### Day 13 - 动态规划收官与设计问题初探：从状态建模到工程封装  
- **完成题目**：  
  - [x] [198] 打家劫舍  
  - [x] [384] 打乱数组  
  - [x] [155] 最小栈  

- **学习重点**：  
  - **掌握“互斥选择”下的状态转移范式**（题 [198]）：通过定义 `dp[i]` 为“考虑前 `i+1` 户时能偷的最大金额”，自然导出 `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。关键在于理解：**“不偷当前户”继承 `dp[i-1]`，“偷当前户”则必须跳过前一户，回退至 `dp[i-2]`**。此模型完美编码了“相邻不可同时选”的约束，凸显 DP 对**决策互斥性**的优雅处理。尝试使用 C++23 的递归 lambda 写法 `auto dfs = [&](this auto&& dfs, int i) -> int`，虽语法陌生，但其本质仍是记忆化搜索——将状态 `i` 与递归调用绑定，配合 `memo` 实现 Top-down DP，进一步验证了“状态即子问题”的核心思想。  
  - **理解原地随机算法的数学保证**（题 [384]）：Fisher-Yates 洗牌通过**从后往前、逐步缩小随机范围**（`j ∈ [0, i]`）确保每种排列等概率生成。重点认识到：**“随机数可能重复”不影响正确性**，因每轮操作仅作用于未固定前缀，历史选择不会干扰后续分布。此题揭示设计类问题的新维度：**算法需满足概率均匀性、原地性与 O(n) 复杂度三重约束**，远超单纯逻辑实现。  
  - **实践“状态快照”式辅助结构设计**（题 [155]）：最小栈通过在主栈每个元素中**打包存储 `(value, current_min)`**，使 `getMin()` 仅需访问栈顶即可 O(1) 返回全局最小值。这并非“额外维护一个单调栈”，而是将**历史极值信息内嵌于主数据结构**，体现了设计问题的核心哲学：**以空间冗余换取时间最优，并通过封装隐藏实现细节**。  

- **卡点反思**：  
  - 题 [198] **DP 思维启动滞后**：面对“不能偷相邻房屋”的约束，初始仍试图枚举所有合法子集（暴力回溯），导致指数级复杂度。反映出**未能快速识别“多阶段决策 + 最优子结构”特征**，对 DP 的适用场景缺乏条件反射——今后应主动问：“是否存在可复用的子问题？当前决策是否仅依赖有限历史？”  
  - 题 [384][155] **工程实现能力短板暴露**：虽能口述 Fisher-Yates 或最小栈原理，但在编码时卡在**类成员初始化、方法签名规范、边界处理**等工程细节（如忘记 `srand(time(0))` 导致洗牌结果固定，或最小栈哨兵值设计冗余）。说明**算法理解 ≠ 完整实现**，设计类问题要求同时兼顾**数学正确性、接口鲁棒性与代码简洁性**。  
  - **C++23 递归 Lambda 语法障碍**：对 `this auto&& dfs` 等新特性感到陌生，过度关注语法形式而忽略其本质仍是“带记忆化的递归”。暴露出对语言演进与现代 C++ 范式的跟进不足，需加强“语法为思想服务”的认知——无论写法如何变化，核心仍是状态定义与转移。  

- **收获与改进**：  
  - **动态规划章节闭环认知**：  
    - 从 [70] 的**计数型路径问题**、[121] 的**贪心特例**、[53] 的**连续子数组约束**，到 [198] 的**互斥决策模型**，已覆盖 DP 入门四大范式；  
    - 确立“状态定义 → 转移方程 → 边界处理 → 空间优化”四步解题链，未来面对新题优先尝试此框架；  
  - **设计问题思维转型**：  
    - 认识到设计类题目本质是 **“约束满足 + 接口封装”**：需明确操作复杂度要求（如 O(1)）、数据一致性保证（如洗牌均匀性），并通过私有成员/辅助结构实现；  
    - 初步建立“**API 设计意识**”：公有方法应简洁无歧义（如 `MinStack::getMin()` 不接受参数），内部实现可灵活组合数据结构；  
  - **工程能力补强方向**：  
    - 强化**完整类实现训练**：包括构造函数初始化、成员变量管理、边界 case 处理（如空栈、单元素数组）；  
    - 建立**现代 C++ 语法工具箱**：系统学习 C++11/14/17/20/23 关键特性（如 `emplace`、`auto&&`、`this` 显式对象参数），避免因语法障碍掩盖算法思想；  
  - **专题衔接意识深化**：  
    - 动态规划聚焦**状态演化逻辑**，设计问题强调**系统封装能力**，而即将开启的数学专题将回归**数值性质与计算效率**——需灵活切换“逻辑推导”、“工程实现”、“数学洞察”三种思维模式。
    - 已整理笔记([打家劫舍](https://github.com/Gelise436b/leetcode-notes/blob/main/DynamicProgram/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.md)),([打乱数组](https://github.com/Gelise436b/leetcode-notes/blob/main/DesignIssue/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84.md)),([最小栈](https://github.com/Gelise436b/leetcode-notes/blob/main/DesignIssue/%E6%9C%80%E5%B0%8F%E6%A0%88.md))


- **明日计划**：  
  - **巩固今日三题**：  
    - 手写 [198] 的 Bottom-up DP 与滚动变量优化版，对比递归 lambda 实现；  
    - 重写 [384] 确保 Fisher-Yates 无偏实现（使用 `<random>` 库替代 `rand()`）；  
    - 精简 [155] 最小栈实现，移除哨兵改用空栈判断；  
  - **开启数学专题**：  
    - [412] Fizz Buzz（掌握字符串构建与模运算）；  
    - [204] 计数质数（理解埃氏筛法的时间优化思想）；  
    - [326] 3 的幂（探索数值性质：最大 3 次幂整除判定）；  
  - **构建数学问题解题直觉**：  
    - 区分“模拟计算”（如 FizzBuzz）、“数学优化”（如质数筛法）、“性质利用”（如 3 的幂）三类子问题；  
    - 关注**时间复杂度下限**（如质数计数能否优于 O(n√n)）与**位运算/对数等数学工具**的应用场景。
      
### Day 14 - 数学专题初探：从规则模拟到数论性质与算法优化  
- **完成题目**：  
  - [x] [412] Fizz Buzz  
  - [x] [204] 计数质数  
  - [x] [326] 3 的幂  

- **学习重点**：  
  - **掌握“规则映射”型模拟题的简洁实现**（题 [412]）：通过清晰的模运算分支（`%15`、`%3`、`%5`）直接输出对应字符串，避免冗余拼接或截取操作。关键在于**将自然语言规则无损转化为代码逻辑**，并以字面量 `"Fizz"`/`"Buzz"` 保证可读性与效率。此题虽基础，却强化了“**输入→条件→输出**”的结构化建模范式，为后续复杂模拟奠定思维习惯。  
  - **理解筛法对质数判定的范式跃迁**（题 [204]）：首次系统学习**埃拉托斯特尼筛法**（Eratosthenes Sieve），其核心思想是**从“逐个验证”转向“批量标记”**——利用每个合数必有最小质因数的性质，从 $p^2$ 起步标记倍数，避免重复操作。时间复杂度从暴力 $O(n\sqrt{n})$ 降至 $O(n \log \log n)$，深刻体会到**数学结构洞察对算法效率的颠覆性提升**。  
  - **探索“数值整除性质”在幂判定中的巧用**（题 [326]）：尝试递归解法时，因**遗漏 `n <= 0` 边界条件**导致栈溢出（如 `n=0` 陷入无限递归），暴露出对递归基的疏忽；同时学到更优策略：利用 3 是质数的特性，以最大 3 的幂 `1162261467` 对 `n` 取模，实现 O(1) 判定。这揭示数学题的双重路径：**通用方法**（循环/递归），需警惕边界；**特化技巧**（大幂整除），依赖数论性质但高效简洁。  

- **卡点反思**：  
  - 题 [326] **递归边界处理缺失**：仅关注“能否被 3 整除”的递推逻辑，却忽略 `n <= 0` 和 `n = 1` 的终止条件，导致程序崩溃。反映出**递归设计中“基线情形”优先级不足**——今后应先明确合法输入范围（如幂函数定义域为正整数），再构建递推关系。  
  - 题 [204] **筛法细节理解浅层**：初写筛法时误从 `2p` 开始标记（而非 `p²`），虽结果正确但效率略低。说明对“**为何从 `p²` 起标**”的数学依据（小于 `p²` 的 `p` 倍数已被更小质数标记）未深究，需加强“**算法步骤 ↔ 数学原理**”的双向验证意识。  
  - **“大幂整除”适用性认知模糊**：初见 `1162261467 % n == 0` 时误以为通用技巧，后经反思才明确其**仅适用于底数为质数且范围受限的场景**（如 2、3、5 的幂）。警示自己：**数学捷径必有前提约束，不可盲目迁移**。  

- **收获与改进**：  
  - **数学问题分类框架初建**：  
    - **模拟计算类**（如 [412]）：重规则清晰与实现简洁；  
    - **算法优化类**（如 [204]）：重复杂度分析与结构洞察；  
    - **性质利用类**（如 [326]）：重数论知识与边界意识；  
    → 未来解题先判类型，再选策略；  
  - **工程鲁棒性意识提升**：  
    - 递归/循环必先处理 `n <= 0`、空输入等非法边界；  
    - 数学技巧需自问：“该性质是否普适？前提是什么？”；  
  - **现代 C++ 实践深化**：  
    - [204] 中使用 `vector<bool>` 优化空间，理解其特化存储机制；  
    - [326] 对比递归、循环、数学三种解法，体会“**正确性 → 效率 → 简洁性**”的演进路径；  
  - **专题衔接能力增强**：  
    - 数学题非孤立计算，而是**动态规划**（状态转移）、**设计问题**（接口封装）的底层支撑；  
    - 如质数筛法可嵌入加密设计，幂判定可优化哈希函数——需建立“**数学为用，不止于算**”的认知。
    - 已整理笔记([计算质数](https://github.com/Gelise436b/leetcode-notes/blob/main/math/%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0.md)),([3的幂](https://github.com/Gelise436b/leetcode-notes/blob/main/math/3%E7%9A%84%E5%B9%82.md))

- **明日计划**：  
  - **巩固今日核心难点**：  
    - 重写 [204] 埃氏筛，确保从 `p²` 起标，并分析空间优化方案；  
    - 修正 [326] 递归解法，补充 `n <= 0` 判断，并手推 `1162261467 = 3¹⁹` 的由来；  
  - **推进数学专题剩余题目**：  
    - [13] 罗马数字转整数（掌握符号映射与贪心解析）；  
    - [191] 位1的个数（实践位运算技巧：`n & (n-1)`）；  
    - [461] 汉明距离（理解异或 + 位计数的组合应用）；  
  - **构建位运算与进制转换直觉**：  
    - 归纳“**位操作三板斧**”：掩码（masking）、移位（shifting）、消位（`n & (n-1)`）；  
    - 对比罗马数字（非位置制）与二进制（位置制）的解析差异，深化进制本质理解。

### Day 15 - 位运算初探：从进制解析到二进制操作的范式跃迁  

- **完成题目**：  
  - [x] [13] 罗马数字转整数  
  - [x] [191] 位1的个数  
  - [x] [461] 汉明距离  

- **学习重点**：  
  - **掌握“符号映射 + 贪心解析”在非位置制转换中的应用**（题 [13]）：罗马数字虽无位权，但其**减法规则具有局部最优性**——从左至右扫描，若当前值小于后一位，则整体视为一个减法单元（如 `IV`）。实现时通过**预判下一位**（`i+1 < n`）避免越界，并以 `map<char, int>` 建立符号到数值的直连映射。此题强化了“**规则驱动解析**”的通用模式，为后续表达式求值、编译原理等场景埋下伏笔。  
  - **理解位计数问题的算法分层**（题 [191] & [461]）：初解依赖 `bitset<32>(n).to_string()` 遍历统计，虽正确但**隐含 O(32) 固定开销且未触及位运算本质**；深入后习得 **Brian Kernighan 算法**（`n &= n - 1`），其核心在于**利用二进制结构特性跳过零位**——每次操作精准消除最右 `1`，循环次数等于 `1` 的个数。此技巧不仅将 [191] 优化至 O(k)（k 为 1 的数量），更成为 [461] 汉明距离的基石（先 `x ^ y` 得差异位图，再用 Kernighan 计数）。二者共通点揭示：**位运算的威力不在“逐位检查”，而在“结构感知的批量操作”**。  

- **卡点反思**：  
  - **位运算认知停留在表层工具集**：此前仅知 `&`、`|`、`>>` 等基础操作，却未理解其**与二进制代数结构的深层关联**。面对 [191]/[461] 时，本能选择“转字符串遍历”这种**降维解法**，暴露出对位运算“原生能力”的陌生——未能将“计数 1”直接建模为位操作问题，而是绕道字符串处理，牺牲效率与简洁性。  
  - **Brian Kernighan 算法原理模糊**：初见 `n &= n - 1` 时仅机械记忆“消去最低位 1”，未深究其**数学依据**（`n-1` 将最低位 `1` 及其后缀 `0` 翻转，与原数 `&` 后清零该 `1`）。导致无法灵活迁移至其他场景（如检测 2 的幂：`n > 0 && (n & (n-1)) == 0`），反映出**对位技巧缺乏“可推导性”理解**。  
  - **进制系统思维割裂**：处理 [13]（非位置制）与 [191]/[461]（位置制）时，未主动对比二者解析逻辑差异——前者依赖**上下文规则匹配**，后者依赖**位独立性与代数性质**。说明尚未建立“**进制即编码协议**”的统一视角，限制了跨题型迁移能力。  

- **收获与改进**：  
  - **位运算能力框架初显**：  
    - **基础操作层**：掩码（`& mask`）、移位（`>>`/`<<`）用于提取/移动位；  
    - **结构利用层**：`n & (n-1)` 消位、`n & -n` 取最低位 1，基于补码代数性质；  
    - **组合应用层**：异或（`^`）表差异、与或非构建逻辑电路；  
    → 未来遇位问题，先问：“能否用结构特性跳过冗余操作？”；  
  - **算法选择意识升级**：  
    - 拒绝“能跑就行”的字符串中转，坚持**在原生数据域内求解**（如直接位操作而非转字符串）；  
    - 对 O(1)、O(log n)、O(k) 等复杂度标签保持敏感，主动追问“是否存在更优路径？”；  
  - **数学与工程协同深化**：  
    - Brian Kernighan 算法是**数论（二进制表示唯一性）与工程（CPU 位指令高效）的完美结合**；  
    - 罗马数字解析体现**形式语言（有限状态机）在简单场景的轻量应用**；  
    → 坚信：**优雅代码 = 数学洞察 × 工程约束**；  
  - **专题衔接能力延伸**：  
    - 位运算为**哈希设计**（位掩码分桶）、**状态压缩 DP**（状态编码）提供底层支持；  
    - 进制转换思维可迁移至**网络协议解析**（字节序处理）、**加密算法**（位混淆）——需持续构建“**位即资源**”的认知。  

- **明日计划**：  
  - **巩固位运算核心技巧**：  
    - 手推 Brian Kernighan 算法在 `n=0~15` 的执行过程，验证“消位”机制；  
    - 实现 [191] 的三种解法（字符串遍历、循环移位、Kernighan），对比性能与可读性；  
  - **推进初级算法剩余题目**：  
    - [190] 颠倒二进制位（实践位提取与重组：`res = (res << 1) | (n & 1)`）；  
    - [118] 杨辉三角（掌握动态规划的二维递推与空间优化）；  
    - [20] 有效的括号（应用栈解决嵌套匹配问题，理解 LIFO 语义）；  
  - **构建位操作直觉体系**：  
    - 归纳“**位重组三要素**”：提取（`n & 1`）、移位（`<<`/`>>`）、拼接（`|`）；  
    - 对比 [190]（位顺序反转）与 [461]（位差异计数），提炼“**位操作问题分类树**”。
