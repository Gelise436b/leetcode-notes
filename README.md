# leetcode-notes
My LeetCode study notes and solutions
## 📅 学习日志
## 📚 目录（点击跳转）
- [Day 1 - 数组基础](#day-1---数组基础)
- [Day 2 - 哈希表与位运算初探](#day-2---哈希表与位运算初探)
- [Day 3 - 数组进阶与哈希表应用](#day-3---数组进阶与哈希表应用)
- [Day 4 - 矩阵操作与字符串基础](#day-4---矩阵操作与字符串基础)
- [Day 5 - 字符串处理与整数边界](#day-5---字符串处理与整数边界)
- [Day 6 - 字符串处理进阶与边界细节](#day-6---字符串处理进阶与边界细节)
- [Day 7 - 字符串收官与链表初探](#day-7---字符串收官与链表初探)
- [Day 8 - 链表核心技法突破](#day-8---链表核心技法突破)
- [Day 9 - 链表收官 & 树章节启航](#day-9---链表收官--树章节启航)
- [Day 10 - 树专题攻坚 & 遍历思维深化](#day-10---树专题攻坚--遍历思维深化)
- [Day 11 - 树专题收尾 & 排序/搜索入门](#day-11-树专题收尾-排序搜索入门)
### Day 1 - 数组基础
- **完成题目**：
  - [x] [26] 删除有序数组中的重复项  
  - [x] [189] 轮转数组  
  - [ ] [122] 买卖股票的最佳时机 II ❌（未独立完成）
- **学习重点**：
  - 掌握双指针原地去重（题 26）
  - 理解数组轮转的**三次反转技巧**（题 189）
- **卡点反思**：
  - 题 [122] 卡在“如何多次买卖求最大利润”，**未能想到贪心策略**。
  - 初次接触贪心算法，不理解“为什么每天上涨都交易能得到全局最优”。
  - 误以为需要记录买入点，陷入复杂状态判断，忽略了**利润可拆分为所有正差价之和**的本质。
- **收获与改进**：
  - 通过题解理解了贪心的核心：**局部最优（每天赚就卖） ⇒ 全局最优（总利润最大）**
  - 已整理详细笔记（见 [买卖股票的最佳时机 II](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.md)）
- **明日计划**：
  - 手写 [122] 的 C++ 实现，默写一遍
  - 开始 Day 2：（217, 136, 350）

---


### Day 2 - 哈希表与位运算初探  
- **完成题目**：  
  - [x] [217] 存在重复元素  
  - [x] [136] 只出现一次的数字  
  - [x] [350] 两个数组的交集 II  

- **学习重点**：  
  - 掌握使用 `unordered_set` 判断元素是否存在（题 217）  
  - 理解**异或运算的性质**：`a ^ a = 0`，`a ^ 0 = a`，满足交换律与结合律（题 136）  
  - 回顾哈希表（`unordered_map`）统计频次并求交集的方法（题 350）  

- **卡点反思**：  
  - 题 [217] 中对 C++ `set` / `unordered_set` 的基本操作（如 `insert()`、`count()`）记忆模糊，导致编码迟疑。  
  - 题 [350] 本想用哈希表高效求解，但一时忘记如何用 `map` 统计频次并处理重复元素，退而使用了排序+双指针（虽可行但非最优复习目标）。  
  - 题 [136] 虽独立完成（使用 set 或 map），但**未主动想到异或解法**，说明对位运算的敏感度不足。  

- **收获与改进**：  
  - 深刻体会到**异或运算是解决“唯一出现”类问题的利器**，简洁且 O(1) 空间。  
  - 意识到 STL 容器（尤其是 `unordered_set` 和 `unordered_map`）的常用接口需要定期巩固。  
  - 已整理笔记：([存在重复元素](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md)),([只出现一次的数字](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md))

- **明日计划**：  
  - 完成新题：[344] 反转字符串、[151] 反转字符串中的单词、[88] 合并两个有序数组  
  - 复习今日三题（217, 136, 350），重点手写哈希表与异或解法  
  - 补充复习 C++ `unordered_set` / `unordered_map` 常用方法  

---

### Day 3 - 数组进阶与哈希表应用  
- **完成题目**：  
  - [x] [66] 加一  
  - [x] [283] 移动零  
  - [x] [1] 两数之和  

- **学习重点**：  
  - 理解数组末尾“进位”处理的边界情况（题 66）  
  - 掌握**双指针原地移动元素**的思想，实现非零元素前移、零元素后置（题 283）  
  - 熟悉使用 `unordered_map` 实现“值 → 下标”的快速映射，解决配对问题（题 1）  

- **卡点反思**：  
  - 题 [66] 在处理连续 9 的进位时逻辑混乱，**未清晰拆解“从后往前遍历 + 进位标志”** 的流程，导致边界（如 `[9,9,9] → [1,0,0,0]`）处理失败。  
  - 题 [283] 虽知道要用双指针，但混淆了快慢指针的职责：**慢指针应指向下一个非零元素应放置的位置**，而非简单交换。初期尝试用额外数组，违背了“原地操作”要求。  
  - 题 [1] 虽知道可用哈希表，但对 `map.count(target - num)` 判断是否存在、以及何时插入当前元素存在犹豫，**未能形成“先查后插”的标准流程**，担心重复或顺序问题。  

- **收获与改进**：  
  - 明白了数组模拟加法的核心是**逆序遍历 + 进位传播**，若全程无中断进位，则需在头部补 1。  
  - 掌握了“快指针扫描、慢指针写入”的双指针模板，适用于**过滤/移动特定元素**类问题。  
  - 巩固了哈希表在“两数之和”类问题中的标准解法：**遍历时先检查 complement 是否存在，不存在再将当前元素加入 map**，避免自身重复使用。  
  - 已整理笔记：([加一](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8A%A0%E4%B8%80.md))、([移动零](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E7%A7%BB%E5%8A%A8%E9%9B%B6.md))、([两数之和](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md))

- **明日计划**：  
  - 手写三题（66, 283, 1）的 C++ 实现，重点默写双指针与哈希表逻辑  
  - 复习今日错点：进位边界、快慢指针分工、map 查询与插入时机  
  - 开始 Day 4：（36.有效的数独、48.旋转图像、344.反转字符串）  

--- 
### Day 4 - 矩阵操作与字符串基础  
- **完成题目**：  
  - [x] [36] 有效的数独  
  - [x] [48] 旋转图像  
  - [x] [344] 反转字符串  

- **学习重点**：  
  - 掌握利用**三维布尔数组**或**哈希集合**对数独的行、列、3×3 宫格进行独立校验（题 36）  
  - 理解矩阵**顺时针旋转 90° 的两步法**：先转置（transpose），再逐行反转（题 48）  
  - 熟悉字符串原地反转的**双指针交换**模板，首尾相向移动直至相遇（题 344）  

- **卡点反思**：  
  - 题 [36] 能想到用 `row_has[i][num]` 和 `col_has[j][num]` 分别记录行和列的数字出现情况，但**卡在如何标识 3×3 宫格**。起初试图用复杂条件判断所属宫格，未意识到 `(i/3, j/3)` 可自然将 9×9 划分为 3×3 的块坐标，导致无法统一建模。  
  - 题 [48] 完全**缺乏旋转的几何直觉**，尝试直接推导新旧坐标映射关系失败，也未联想到“转置 + 反转”这一经典组合技巧，陷入硬编码坐标的误区。  
  - 题 [344] 实现顺利，但初期担心 `char` 类型交换是否需特殊处理，实则 C++ 中 `swap` 对字符完全适用，属于不必要的犹豫。  

- **收获与改进**：  
  - 明白了数独中 **3×3 子网格的索引可通过 `i/3` 和 `j/3` 整除压缩**，从而用 `sub_box[3][3][9]` 精准定位每个宫格的状态，实现 O(1) 校验。  
  - 掌握了**矩阵旋转的通用思维**：不直接硬算，而是拆解为基本操作（如转置、翻转）的组合，极大降低实现难度。  
  - 巩固了字符串原地操作的双指针模式，确认其适用于所有“对称交换”类问题，代码简洁且空间最优。  
  - **今日正式完成 LeetCode 初级算法《数组》章节全部内容**，建立起对数组边界处理、原地操作、哈希映射及矩阵变换的基本解题框架。  
  - 已整理笔记：([有效的数独](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC.md))、([旋转图像](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F.md))、
- **明日计划**：  
  - 手写三题（36, 48, 344）的 C++ 实现，重点默写宫格索引计算、矩阵转置+反转流程、字符串双指针交换  
  - 复习今日核心技巧：`i/3, j/3` 宫格划分、矩阵旋转的两步法、原地反转模板  
  - 开始 Day 5：继续 LeetCode 初级算法 —— 字符串专题（7.整数反转、387. 字符串中的第一个唯一字符、242. 有效的字母异位词、）
### Day 5 - 字符串处理与整数边界  
- **完成题目**：  
  - [x] [7] 整数反转  
  - [x] [387] 字符串中的第一个唯一字符  
  - [x] [242] 有效的字母异位词  

- **学习重点**：  
  - 掌握**整数反转时的溢出判断技巧**（题 7）：在每次更新结果前，通过 `res > INT_MAX / 10` 或 `res < INT_MIN / 10` 预判是否越界，避免直接计算导致未定义行为。  
  - 学会使用 **`unordered_map` + `string::find()` 结合迭代器比较** 的方式定位唯一字符（题 387），理解 `s.find(c) == s.rfind(c)` 或 `map.count(c) == 1 && first_occurrence == last_occurrence` 等等价思路。  
  - 理解**字母异位词（Anagram）** 的定义：两个字符串包含**完全相同的字符及其频次**，仅顺序不同（如 "listen" 与 "silent"）。验证方法通常为**字符频次统计**或**排序后比较**（题 242）。  

- **卡点反思**：  
  - 题 [242] 虽能写出正确代码（如用哈希表统计频次），但**初始不理解“字母异位词”的确切含义**，反映出对基础术语掌握不足，影响问题建模速度。  
  - 题 [387] 最初仅想到两次遍历计数+再遍历找首个频次为1的字符，**未意识到可利用 `find` 与 `rfind` 返回位置是否相等来直接判断唯一性**，新方法更简洁且无需额外存储频次。  
  - 题 [7] 在处理负数和末尾零时逻辑稍显混乱，初期未统一用 `long` 或提前截断，导致边界测试用例（如 `1534236469`）失败。  

- **收获与改进**：  
  - 明确了**字母异位词 = 字符组成完全一致（频次相同）**，今后遇到类似描述可快速联想到频次哈希或排序策略。  
  - 掌握了**利用字符串查找函数判断字符唯一性**的新技巧：若 `s.find(c) == s.rfind(c)`，说明该字符仅出现一次，适用于首个唯一字符类问题。  
  - 巩固了**整数操作中的防溢出意识**，学会在循环体内做“预检查”而非事后判断，提升代码鲁棒性。  
  - 初步建立起字符串问题的两大核心思路：**频次统计（哈希）** 与 **顺序无关化（排序）**，为后续字符串专题打下基础。  

- **明日计划**：  
  - 手写三题（7, 387, 242）的 C++ 实现，重点默写溢出判断条件、`find/rfind` 唯一性判断、异位词的哈希/排序两种解法  
  - 复习今日核心概念：字母异位词定义、整数反转防溢出模板、字符串唯一字符的多种判定方式  
  - 开始 Day 6：继续 LeetCode 初级算法 —— 字符串专题（125. 验证回文串、88. 字符串转换整数、28.找出字符串中第一个匹配的下标）

---

### Day 6 - 字符串处理进阶与边界细节  
- **完成题目**：  
  - [x] [125] 验证回文串  
  - [x] [8] 字符串转换整数（atoi）  
  - [x] [28] 找出字符串中第一个匹配项的下标  

- **学习重点**：  
  - 掌握**回文串验证的标准处理流程**（题 125）：忽略非字母数字字符、统一大小写后使用双指针比对。关键工具函数 `isalnum()` 可高效判断字符是否为字母或数字，避免手动枚举字符范围。  
  - 理解 **`atoi` 实现中的状态机思维**（题 8）：依次处理前导空格 → 符号位 → 数字部分 → 溢出截断。需注意不能依赖 `isdigit` 或 `isalnum` 过度简化逻辑，而应严格按题意分阶段解析。  
  - 初步接触**字符串匹配的两种策略**（题 28）：  
    - 简洁解法：直接调用 `haystack.find(needle)`；  
    - 高效解法：KMP 算法（当前尚未掌握，需后续专项学习）。  

- **卡点反思**：  
  - 题 [125] **未第一时间想到使用 `isalnum()`**，试图手动判断 `'a'-'z'`、`'A'-'Z'`、`'0'-'9'`，导致代码冗长且易漏边界（如大写转小写不彻底），反映出对 C++ 标准库字符处理函数不熟悉。  
  - 题 [8] 在解析数字时**错误尝试用 `isalnum` 辅助判断**，混淆了“字母数字”与“纯数字”的区别（例如 `'a'` 是 alnum 但不是 digit），导致逻辑混乱。正确做法应使用 `isdigit` 或直接比较 `'0' <= c <= '9'`。  
  - 题 [28] **完全依赖 `find()` 取巧通过**，对 KMP 算法原理一无所知，暴露出在“不调库”场景下的算法能力短板，尤其在面试要求手写匹配逻辑时会陷入被动。  

- **收获与改进**：  
  - 明确了 **C++ 字符分类函数的适用场景**：  
    - `isalnum(c)`：判断是否为字母或数字（用于回文过滤）；  
    - `isdigit(c)`：仅判断是否为数字（用于 atoi 解析）；  
    - `tolower(c)/toupper(c)`：安全进行大小写转换。  
  - 意识到 **复杂字符串解析题需分阶段建模**（如 atoi 的“跳空格→读符号→累加数字→防溢出”四步），避免试图一步到位。  
  - 认清了 **KMP 是字符串匹配的核心算法之一**，虽可暂时用库函数过关，但必须列入后续重点攻克清单。
  - 已整理笔记([验证回文串](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.md)),([字符串转换整数](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0.md)),([找出字符串中第一个匹配的下标项](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.md))

- **明日计划**：  
  - **手写重做今日三题（125, 8, 28）**，重点练习：  
    - 使用 `isalnum + tolower` 实现干净的回文判断；  
    - 不依赖任何转换函数，手动实现 atoi 的完整状态逻辑；  
    - 尝试写出暴力版 strStr（双层循环），并初步阅读 KMP 原理。  
  - **推进 LeetCode 初级算法新题**：  
    - [38] 外观数列  
    - [14] 最长公共前缀  
    - [237] 删除链表中的节点（注意：此题为“伪删除”，仅给定待删节点指针）  
  - 复习字符处理标准库函数，整理常用 API 速查表。

---
### Day 7 - 字符串收官与链表初探  
- **完成题目**：  
  - [x] [38] 外观数列  
  - [x] [14] 最长公共前缀（至此完成 LeetCode 初级算法 · 字符串全部题目）  
  - [x] [237] 删除链表中的节点  

- **学习重点**：  
  - 掌握**外观数列的递归建模思路**（题 38）：理解 `countAndSay(n)` 依赖于 `countAndSay(n-1)` 的返回结果，将问题拆解为“先拿到上一层描述字符串，再对其进行连续字符计数与拼接”。关键在于接受递归的“黑盒”思想——不必深究每层调用细节，只需相信前一层能正确返回所需字符串。  
  - 熟悉**最长公共前缀的矩阵视角**（题 14）：将字符串数组视为字符矩阵，逐列比对所有行在该列的字符是否一致。一旦某列出现不匹配或到达某字符串末尾，即终止并返回当前前缀。这种“垂直扫描”策略简洁高效，优于横向两两比较。  
  - 理解**链表“伪删除”的实现本质**（题 237）：题目仅提供待删节点指针，无法访问前驱。解决方案是**将下一节点的内容拷贝到当前节点**，再跳过下一节点。核心操作为 `*node = *(node->next)`（C++）或等价的字段赋值（如 `val` 和 `next` 分别覆盖），而非简单移动指针。  

- **卡点反思**：  
  - 题 [38] **递归思维未建立**：卡在无法想象 `string previous = countAndSay(n - 1)` 的具体返回形态，导致无法在此基础上进行字符遍历与计数拼接。反映出对递归“自顶向下分解、自底向上构建”的过程缺乏直觉。  
  - 题 [14] **缺乏结构化视角**：未将字符串数组抽象为二维字符矩阵，执着于逐字符串两两求交集，逻辑复杂且易错。未能第一时间想到“按列统一检查”这一更优策略。  
  - 题 [237] **混淆指针与解引用语义**：错误地写成 `node = node->next`，这只是局部指针变量重定向，并未修改原链表结构；正确做法需通过 `*node = *(node->next)` 覆盖当前节点内容（或分别赋值 `val` 和 `next`），真正实现“值覆盖式删除”。  

- **收获与改进**：  
  - 明确了**递归函数设计的关键信任原则**：只要 base case 正确、递推关系清晰，就应相信子调用能返回正确结果，专注当前层的处理逻辑。  
  - 强化了**多字符串处理的“矩阵化”思维**：对于涉及多个等长/变长字符串的公共操作（如前缀、列对齐），尝试将其视为二维结构，常能简化问题。  
  - 深刻认识到**链表操作中“修改节点内容”与“修改指针指向”的区别**：尤其在受限条件下（如无前驱指针），需灵活运用值拷贝实现逻辑删除。  
  - 已完成 LeetCode 初级算法 · 字符串模块全部内容，标志着字符串基础处理能力初步成型。
  - 已整理笔记([外观数列](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97.md)),([最长公共前缀](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.md))([删除链表中的节点](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md))

- **明日计划**：  
  - **复习今日三题（38, 14, 237）**，重点练习：  
    - 手写外观数列的迭代与递归两种实现，强化递归建模能力；  
    - 实现最长公共前缀的“垂直扫描”法，并对比横向方法的差异；  
    - 重做 237 题，确保理解 `*node = *(node->next)` 的内存含义。  
  - **回顾 Day 6 的 KMP 相关内容**：重读 [28] 题笔记，尝试手写暴力版 `strStr`，并初步理解 KMP 的 next 数组思想。  
  - **推进 LeetCode 初级算法 · 链表部分**：  
    - [19] 删除链表的倒数第 N 个节点  
    - [206] 反转链表  
    - [21] 合并两个有序链表
    - 
### Day 8 - 链表核心技法突破  
- **完成题目**：  
  - [x] [19] 删除链表的倒数第 N 个节点  
  - [x] [206] 反转链表  
  - [x] [21] 合并两个有序链表  

- **学习重点**：  
  - 掌握**快慢指针在链表中的通用模式**（题 19）：通过让快指针先走 `N` 步，再同步移动快慢指针，使慢指针最终停在待删节点的前驱位置。关键在于理解“距离差恒定”这一思想——快慢指针间距始终为 `N`，当快指针到达末尾时，慢指针自然指向倒数第 `N+1` 个节点。此技巧是处理“倒数第 K 个”类问题的标准解法。  
  - 熟悉**链表反转的迭代实现逻辑**（题 206）：采用头插法思想，遍历原链表并将每个节点插入到新链表的头部。核心三步操作：保存下一节点（`next = cur->next`）、当前节点指向前驱（`cur->next = prev`）、更新前驱与当前指针（`prev = cur; cur = next`）。避免陷入递归细节，优先掌握清晰可控的迭代写法。  
  - 理解**有序链表合并的“尾接剩余”策略**（题 21）：在双指针遍历结束后，必有一个链表非空。无需复杂判断，直接使用 `cur->next = list1 ? list1 : list2;` 即可将剩余有序部分整体接入结果链表末尾，简洁且高效。  

- **卡点反思**：  
  - 题 [19] **快慢指针迁移能力不足**：虽在数组/字符串中熟练使用双指针，但面对链表指针操作时未能及时联想。反映出对“指针即位置”的抽象理解不够——链表中的指针本质仍是位置标识，快慢指针的相对距离思想完全适用。  
  - 题 [206] **基础操作记忆模糊**：遗忘头插法的核心步骤，试图用复杂逻辑重构反转过程，导致代码混乱。说明对链表基本操作（如头插、尾插）缺乏肌肉记忆，需回归基础手法训练。  
  - 题 [21] **过度复杂化边界处理**：在循环结束后纠结于“如何判断哪个链表为空”，试图分别检查 `list1` 和 `list2`，忽略了三元运算符 `?:` 的简洁表达力。暴露出对 C++ 条件表达式的灵活运用不熟练。  

- **收获与改进**：  
  - 明确了**快慢指针是跨数据结构的通用技巧**：无论数组索引还是链表指针，只要涉及“相对位置”或“延迟访问”，均可考虑双指针策略。  
  - 重建了**链表基本操作的直觉**：头插法、尾插法、指针重连等是链表题的原子操作，必须像背乘法表一样熟练。  
  - 强化了**简洁边界处理意识**：对于“剩余部分拼接”类问题，善用 `a ? a : b` 或 `if (a) p->next = a; else p->next = b;` 可大幅简化逻辑。  
  - 已系统覆盖 LeetCode 初级算法 · 链表模块的核心题型（删除、反转、合并），为后续复杂链表问题打下坚实基础。
  - 已整理笔记:([删除链表的倒数第n个节点](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9.md)),([反转链表](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md)),([合并两个有序链表](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md))

- **明日计划**：  
  - **复习今日三题（19, 206, 21）**，重点练习：  
    - 手写快慢指针删除倒数第 N 节点的完整代码，确保 dummy 节点与指针移动逻辑无误；  
    - 默写反转链表的迭代版本，强化“保存下一节点 → 反转指针 → 更新状态”三步流程；  
    - 实现合并链表的两种写法（显式 if-else 与三元运算符），体会简洁性差异。  
  - **完成 LeetCode 初级算法 · 链表剩余题目**：  
    - [234] 回文链表  
    - [141] 环形链表  
  - **开启新章节 · 树**：  
    - [104] 二叉树的最大深度（初步接触树的递归遍历思想）

  ### Day 9 - 链表收官 & 树章节启航  
- **完成题目**：  
  - [x] [234] 回文链表  
  - [x] [141] 环形链表  
  - [x] [104] 二叉树的最大深度  

- **学习重点**：  
  - 掌握**回文链表的“快慢指针 + 局部反转”组合技法**（题 234）：先用快慢指针定位链表中点，再将后半部分原地反转，最后双指针从头与中点向两侧同步比对。该解法空间复杂度 O(1)，是处理链表回文问题的最优策略，体现了“分阶段操作链表”的高阶思维。  
  - 巩固**环形检测的 Floyd 判圈算法**（题 141）：快指针每次走两步，慢指针每次走一步，若存在环则二者必在环内相遇。此方法无需额外空间，逻辑简洁且鲁棒性强，已成为判断链表/序列是否存在循环的标准范式。  
  - 初识**树的两种遍历范式**（题 104）：  
    - **DFS（递归后序）**：自然契合“子问题分解”思想，代码简洁；  
    - **BFS（层序迭代）**：通过队列逐层推进，直观体现“按层计数”逻辑。  
    二者分别对应“深度”与“广度”的核心抽象，是后续所有树问题的基石。  

- **卡点反思**：  
  - 题 [234] **模块化思维缺失**：虽已掌握快慢指针（Day 8 题 19）和链表反转（Day 8 题 206），但未能主动将二者**组合应用**于新场景。反映出对“算法组件复用”意识薄弱——应视快慢指针、反转、合并等为可拼装的“工具块”，而非孤立技巧。  
  - 题 [104] **基础算法记忆断层**：面对简单树题竟遗忘 DFS/BFS 的标准实现，暴露出对数据结构核心遍历模式缺乏系统性巩固。说明前期学习偏重“做题”而忽视“框架梳理”，导致知识碎片化。  
  - 整体**跨章节迁移能力待提升**：链表与树虽结构不同，但指针操作、递归思想、双指针策略高度相通，需建立“数据结构共性认知”。  

- **收获与改进**：  
  - **正式完成 LeetCode 初级算法 · 链表全章**，建立起“指针操作 → 算法组合 → 空间优化”的完整解题链条；  
  - **成功开启树章节**，初步感知递归与层序遍历的双重威力，明确树问题“自顶向下”与“自底向上”的思考路径；  
  - 意识到**算法不是孤立技巧，而是可组合的积木**：快慢指针+反转=回文检测，递归+max=最大深度，未来需强化“识别子问题 → 调用已有模块”的能力；  
  - 重新锚定**基础遍历算法的核心地位**：DFS/BFS 不仅是树的基础，更是图论、状态搜索等问题的起点，必须形成肌肉记忆。
  - 已整理笔记([回文链表](https://github.com/Gelise436b/leetcode-notes/blob/main/LinkedList/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.md)),([二叉树的最大深度](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.md))

- **明日计划**：  
  - **重点复习今日薄弱环节**：  
    - 手写 [234] 回文链表完整代码，确保“找中点 → 反转后半段 → 双指针比对 → （可选）恢复链表”四步流程无误；  
    - 默写 [104] 的 DFS 与 BFS 两种解法，强化树遍历模板记忆；  
  - **推进树章节核心题型**：  
    - [98] 验证二叉搜索树（BST 性质 + 中序遍历单调性）  
    - [101] 对称二叉树（递归镜像比对 / BFS 双端队列）  
    - [102] 二叉树的层序遍历（BFS 标准模板深化）  
  - **建立树问题分类意识**：按“遍历类”、“验证类”、“构造类”初步归类，构建解题策略地图。
    
 ### Day 10 - 树专题攻坚 & 遍历思维深化  
- **完成题目**：  
  - [x] [98] 验证二叉搜索树  
  - [x] [101] 对称二叉树  
  - [x] [102] 二叉树的层序遍历  
  - [x] 复习 [234] 回文链表、[104] 二叉树的最大深度  

- **学习重点**：  
  - **掌握 BST 验证的中序遍历核心思想**（题 98）：BST 的中序遍历必为严格递增序列。通过全局前驱值 `pre` 在递归中实时校验单调性，实现 O(n) 时间、O(h) 空间的优雅解法。此题再次印证“树的性质 ⇨ 遍历顺序”的映射关系——**选对遍历方式，问题迎刃而解**。  
  - **深化“镜像对称”的递归建模能力**（题 101）：对称 ≠ 左右子树结构相同，而是 **左子树的左 ↔ 右子树的右** 且 **左子树的右 ↔ 右子树的左** 同时成立。该题训练了“双指针同步递归”的思维模式，是处理树结构关系类问题的关键范式。  
  - **巩固层序遍历的 BFS 实现逻辑**（题 102）：通过维护当前层节点列表（或队列），逐层收集值并生成下一层节点，清晰体现“广度优先”的层次推进特性。使用双数组（`que` 与 `tmp`）虽非最简，但逻辑直观，适合初学阶段建立空间分层认知。  

- **卡点反思**：  
  - 题 [98] **遍历方式混淆与递归过度复杂化**：初期纠结于前/中/后序的选择，试图用前序传递边界却陷入细节；后意识到中序天然契合“单调性”验证，只需专注 **边界条件（空节点） + 当前节点与前驱比较** 两大要素。反映出对“遍历本质目的”理解不足——**遍历是手段，性质验证才是目标**。  
  - 题 [101] **对称定义理解片面**：仅检查左右子树根节点相等，忽略了子树间的交叉对应关系（左-右 vs 右-左）。暴露出对“结构对称”缺乏空间想象，未能将问题转化为 **两棵树互为镜像** 的标准模型。  
  - 整体**基础遍历模板熟练度仍不足**：面对新题仍需回忆遍历顺序定义，说明 DFS/BFS 尚未形成条件反射。需通过高频默写固化“递归三要素”与“BFS 层控技巧”。  

- **收获与改进**：  
  - **系统串联树遍历与问题性质**：明确中序 → BST 单调性、后序 → 自底向上计算、BFS → 层级操作的对应关系，初步建立“问题特征 → 遍历策略”的决策链；  
  - **强化递归的“黑盒思维”**：在 [98][101] 中实践“只关注当前层逻辑，子问题交给递归”的原则，减少对调用栈的过度追踪，提升编码效率；  
  - **验证类树题解题框架初成**：  
    - BST 验证 → 中序单调性 / 前序区间约束；  
    - 对称验证 → 双指针镜像递归；  
    - 层序输出 → BFS 分层收集；  
  - **认识到“边界即答案”**：树问题的正确性往往由空节点、单节点等边界条件决定，未来需优先设计边界处理逻辑，再扩展一般情况。
  - 已整理笔记([验证二叉搜索树](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md)),([对称二叉树](https://github.com/Gelise436b/leetcode-notes/blob/main/tree/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md))

- **明日计划**：  
  - **收尾树专题**：  
    - 完成 [108] 将有序数组转换为二叉搜索树（利用中序特性 + 二分构造）；  
    - **彻底复习今日三题**：手写 [98][101][102] 的 DFS/BFS 双解法，确保边界条件无遗漏；  
  - **开启排序与搜索专题**：  
    - [88] 合并两个有序数组（双指针原地合并技巧）；  
    - [278] 第一个错误的版本（经典二分查找边界应用）；  
  - **构建专题过渡意识**：树依赖指针与递归，排序/搜索侧重数组与迭代，需主动切换思维模式，同时识别共性（如二分与 BST 的内在关联）。
 
 ### Day 11 - 树专题收尾 & 排序/搜索入门  
- **完成题目**：  
  - [x] [108] 将有序数组转换为二叉搜索树  
  - [x] [88] 合并两个有序数组  
  - [x] [278] 第一个错误的版本  

- **学习重点**：  
  - **掌握“分治 + 递归”构造 BST 的核心逻辑**（题 108）：有序数组天然对应 BST 的中序遍历序列，因此**取中点为根、左右子数组递归构建子树**即可保证高度平衡。关键在于理解“闭区间划分”与“递归基”的设计——当 `left > right` 时返回 `nullptr`，避免越界；中点计算采用 `mid = left + (right - left) / 2` 防溢出且精准分割。此题打通了“数组结构 ⇨ 树形结构”的映射通道，凸显分治思想在构造类问题中的威力。  
  - **深化“原地合并”的双指针逆向思维**（题 88）：面对需将 `nums2` 合并至 `nums1` 且不使用额外空间的要求，正向遍历会覆盖未处理数据，而**从后往前填充**（`p1 = m-1, p2 = n-1, p = m+n-1`）可安全利用 `nums1` 末尾预留空间。该技巧揭示了“空间复用”场景下指针方向选择的重要性——**逆序操作保全原始信息**，是数组原地算法的经典范式。  
  - **建立“二分查找”在边界判定问题中的条件反射**（题 278）：面对单调性（好版本 → 坏版本）与“第一个满足条件”的目标，应立即识别为**左边界二分模型**。通过 `while (left < right)` 循环 + `mid = left + (right - left) / 2` + “坏则保留 mid，好则跳过 mid” 的收缩策略，高效定位首个坏版本。此题标志着从线性暴力到对数优化的思维跃迁。  

- **卡点反思**：  
  - 题 [108] **递归结构建模能力不足**：虽意识到需取中点，但未能将“数组区间”抽象为递归参数，纠结于如何传递子数组（试图切片），忽略了**用索引范围代替实际切割**的轻量级递归设计。反映出对“递归状态表示”的经验欠缺——**子问题 = 原问题 + 更小的输入范围**。  
  - 题 [88] **空间约束下的算法变通意识薄弱**：第一反应是新建数组排序再拷贝，未深入思考题目给出的 `nums1` 长度为 `m+n` 的深意。暴露出对“原地操作”典型场景（如合并、去重）缺乏敏感度，未能主动联想“逆向双指针”这一高频技巧。  
  - 题 [278] **算法复杂度敏感度缺失**：直接采用 O(n) 暴力扫描，在 `n` 极大时必然超时。根本原因是对“有序 + 查找”组合缺乏警觉——**只要数据有序，优先考虑二分** 应成为本能，而非事后补救。  

- **收获与改进**：  
  - **完成树专题闭环，建立构造/验证/遍历三维认知**：  
    - 构造（[108]）→ 分治递归 + 中点选取；  
    - 验证（[98]）→ 中序单调性 / 区间约束；  
    - 遍历（[101][102]）→ DFS 对称建模 / BFS 分层控制；  
  - **开启排序/搜索专题，初识“指针艺术”与“二分哲学”**：  
    - 双指针不仅是同向快慢，更是**逆向协同的空间管理者**（[88]）；  
    - 二分查找不仅是找值，更是**边界判定的精密手术刀**（[278]）；  
  - **强化“问题特征 → 算法范式”的映射能力**：  
    - 有序数组 → 二分 / 双指针；  
    - 原地修改 → 逆向操作防覆盖；  
    - 构造平衡树 → 中点分治；  
  - **认识到“简洁即高效”**：最优解往往规避冗余操作（如数组拷贝、线性扫描），未来需优先评估时间/空间复杂度，再动手编码。
  - 已整理笔记([将有序数组转换为二叉树]()),([合并两个有序数组]()),([第一个错误的版本]())

- **明日计划**：  
  - **巩固今日三题**：  
    - 手写 [108] 的递归构造（闭区间版）与 [88] 的逆向双指针实现；  
    - 默写 [278] 的左边界二分模板，确保循环不变式清晰；  
  - **开启动态规划专题**：  
    - [70] 爬楼梯（理解状态转移方程与斐波那契本质）；  
    - [121] 买卖股票的最佳时机（掌握“历史最小值 + 当前利润”贪心视角）；  
    - [53] 最大子序和（ Kadane 算法与 DP 状态定义）；  
  - **构建专题衔接意识**：排序/搜索侧重“确定性路径”（指针移动、区间收缩），动态规划则关注“状态演化”，需切换至“子问题依赖”思维，同时注意贪心与 DP 的边界（如股票问题）。
