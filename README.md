# leetcode-notes
My LeetCode study notes and solutions
## 📅 学习日志

### Day 1 - 数组基础
- **完成题目**：
  - [x] [26] 删除有序数组中的重复项  
  - [x] [189] 轮转数组  
  - [ ] [122] 买卖股票的最佳时机 II ❌（未独立完成）
- **学习重点**：
  - 掌握双指针原地去重（题 26）
  - 理解数组轮转的**三次反转技巧**（题 189）
- **卡点反思**：
  - 题 [122] 卡在“如何多次买卖求最大利润”，**未能想到贪心策略**。
  - 初次接触贪心算法，不理解“为什么每天上涨都交易能得到全局最优”。
  - 误以为需要记录买入点，陷入复杂状态判断，忽略了**利润可拆分为所有正差价之和**的本质。
- **收获与改进**：
  - 通过题解理解了贪心的核心：**局部最优（每天赚就卖） ⇒ 全局最优（总利润最大）**
  - 已整理详细笔记（见 [买卖股票的最佳时机 II](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.md)）
- **明日计划**：
  - 手写 [122] 的 C++ 实现，默写一遍
  - 开始 Day 2：（217, 136, 350）
好的！根据你提供的信息，我已为你整理出符合 Day 1 风格的 **Day 2 学习日志**如下：

---


### Day 2 - 哈希表与位运算初探  
- **完成题目**：  
  - [x] [217] 存在重复元素  
  - [x] [136] 只出现一次的数字  
  - [x] [350] 两个数组的交集 II  

- **学习重点**：  
  - 掌握使用 `unordered_set` 判断元素是否存在（题 217）  
  - 理解**异或运算的性质**：`a ^ a = 0`，`a ^ 0 = a`，满足交换律与结合律（题 136）  
  - 回顾哈希表（`unordered_map`）统计频次并求交集的方法（题 350）  

- **卡点反思**：  
  - 题 [217] 中对 C++ `set` / `unordered_set` 的基本操作（如 `insert()`、`count()`）记忆模糊，导致编码迟疑。  
  - 题 [350] 本想用哈希表高效求解，但一时忘记如何用 `map` 统计频次并处理重复元素，退而使用了排序+双指针（虽可行但非最优复习目标）。  
  - 题 [136] 虽独立完成（使用 set 或 map），但**未主动想到异或解法**，说明对位运算的敏感度不足。  

- **收获与改进**：  
  - 深刻体会到**异或运算是解决“唯一出现”类问题的利器**，简洁且 O(1) 空间。  
  - 意识到 STL 容器（尤其是 `unordered_set` 和 `unordered_map`）的常用接口需要定期巩固。  
  - 已整理笔记：([存在重复元素](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md)),([只出现一次的数字](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md))

- **明日计划**：  
  - 完成新题：[344] 反转字符串、[151] 反转字符串中的单词、[88] 合并两个有序数组  
  - 复习今日三题（217, 136, 350），重点手写哈希表与异或解法  
  - 补充复习 C++ `unordered_set` / `unordered_map` 常用方法  

--- 
Day 3 - 数组进阶与哈希表应用
完成题目：
[x] [66] 加一
[x] [283] 移动零
[x] [1] 两数之和
学习重点：
理解数组末尾“进位”处理的边界情况（题 66）
掌握双指针原地移动元素的思想，实现非零元素前移、零元素后置（题 283）
熟悉使用 unordered_map 实现“值 → 下标”的快速映射，解决配对问题（题 1）
卡点反思：
题 [66] 在处理连续 9 的进位时逻辑混乱，未清晰拆解“从后往前遍历 + 进位标志” 的流程，导致边界（如 [9,9,9] → [1,0,0,0]）处理失败。
题 [283] 虽知道要用双指针，但混淆了快慢指针的职责：慢指针应指向下一个非零元素应放置的位置，而非简单交换。初期尝试用额外数组，违背了“原地操作”要求。
题 [1] 虽知道可用哈希表，但对 map.count(target - num) 判断是否存在、以及何时插入当前元素存在犹豫，未能形成“先查后插”的标准流程，担心重复或顺序问题。
收获与改进：
明白了数组模拟加法的核心是逆序遍历 + 进位传播，若全程无中断进位，则需在头部补 1。
掌握了“快指针扫描、慢指针写入”的双指针模板，适用于过滤/移动特定元素类问题。
巩固了哈希表在“两数之和”类问题中的标准解法：遍历时先检查 complement 是否存在，不存在再将当前元素加入 map，避免自身重复使用。
已整理笔记：([加一](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8A%A0%E4%B8%80.md))、([移动零](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E7%A7%BB%E5%8A%A8%E9%9B%B6.md))、([两数之和](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md))
明日计划：
手写三题（66, 283, 1）的 C++ 实现，重点默写双指针与哈希表逻辑
复习今日错点：进位边界、快慢指针分工、map 查询与插入时机
开始 Day 4：（977. 有序数组的平方、167. 两数之和 II、561. 数组拆分）

