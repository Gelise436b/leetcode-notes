# leetcode-notes
My LeetCode study notes and solutions
## 📅 学习日志

### Day 1 - 数组基础
- **完成题目**：
  - [x] [26] 删除有序数组中的重复项  
  - [x] [189] 轮转数组  
  - [ ] [122] 买卖股票的最佳时机 II ❌（未独立完成）
- **学习重点**：
  - 掌握双指针原地去重（题 26）
  - 理解数组轮转的**三次反转技巧**（题 189）
- **卡点反思**：
  - 题 [122] 卡在“如何多次买卖求最大利润”，**未能想到贪心策略**。
  - 初次接触贪心算法，不理解“为什么每天上涨都交易能得到全局最优”。
  - 误以为需要记录买入点，陷入复杂状态判断，忽略了**利润可拆分为所有正差价之和**的本质。
- **收获与改进**：
  - 通过题解理解了贪心的核心：**局部最优（每天赚就卖） ⇒ 全局最优（总利润最大）**
  - 已整理详细笔记（见 [买卖股票的最佳时机 II](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.md)）
- **明日计划**：
  - 手写 [122] 的 C++ 实现，默写一遍
  - 开始 Day 2：（217, 136, 350）
好的！根据你提供的信息，我已为你整理出符合 Day 1 风格的 **Day 2 学习日志**如下：

---


### Day 2 - 哈希表与位运算初探  
- **完成题目**：  
  - [x] [217] 存在重复元素  
  - [x] [136] 只出现一次的数字  
  - [x] [350] 两个数组的交集 II  

- **学习重点**：  
  - 掌握使用 `unordered_set` 判断元素是否存在（题 217）  
  - 理解**异或运算的性质**：`a ^ a = 0`，`a ^ 0 = a`，满足交换律与结合律（题 136）  
  - 回顾哈希表（`unordered_map`）统计频次并求交集的方法（题 350）  

- **卡点反思**：  
  - 题 [217] 中对 C++ `set` / `unordered_set` 的基本操作（如 `insert()`、`count()`）记忆模糊，导致编码迟疑。  
  - 题 [350] 本想用哈希表高效求解，但一时忘记如何用 `map` 统计频次并处理重复元素，退而使用了排序+双指针（虽可行但非最优复习目标）。  
  - 题 [136] 虽独立完成（使用 set 或 map），但**未主动想到异或解法**，说明对位运算的敏感度不足。  

- **收获与改进**：  
  - 深刻体会到**异或运算是解决“唯一出现”类问题的利器**，简洁且 O(1) 空间。  
  - 意识到 STL 容器（尤其是 `unordered_set` 和 `unordered_map`）的常用接口需要定期巩固。  
  - 已整理笔记：([存在重复元素](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md)),([只出现一次的数字](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md))

- **明日计划**：  
  - 完成新题：[344] 反转字符串、[151] 反转字符串中的单词、[88] 合并两个有序数组  
  - 复习今日三题（217, 136, 350），重点手写哈希表与异或解法  
  - 补充复习 C++ `unordered_set` / `unordered_map` 常用方法  

--- 
好的！以下是根据你提供的信息，仿照 Day 1 和 Day 2 风格整理的 **Day 3 学习日志**：

---

### Day 3 - 数组进阶与哈希表应用  
- **完成题目**：  
  - [x] [66] 加一  
  - [x] [283] 移动零  
  - [x] [1] 两数之和  

- **学习重点**：  
  - 理解数组末尾“进位”处理的边界情况（题 66）  
  - 掌握**双指针原地移动元素**的思想，实现非零元素前移、零元素后置（题 283）  
  - 熟悉使用 `unordered_map` 实现“值 → 下标”的快速映射，解决配对问题（题 1）  

- **卡点反思**：  
  - 题 [66] 在处理连续 9 的进位时逻辑混乱，**未清晰拆解“从后往前遍历 + 进位标志”** 的流程，导致边界（如 `[9,9,9] → [1,0,0,0]`）处理失败。  
  - 题 [283] 虽知道要用双指针，但混淆了快慢指针的职责：**慢指针应指向下一个非零元素应放置的位置**，而非简单交换。初期尝试用额外数组，违背了“原地操作”要求。  
  - 题 [1] 虽知道可用哈希表，但对 `map.count(target - num)` 判断是否存在、以及何时插入当前元素存在犹豫，**未能形成“先查后插”的标准流程**，担心重复或顺序问题。  

- **收获与改进**：  
  - 明白了数组模拟加法的核心是**逆序遍历 + 进位传播**，若全程无中断进位，则需在头部补 1。  
  - 掌握了“快指针扫描、慢指针写入”的双指针模板，适用于**过滤/移动特定元素**类问题。  
  - 巩固了哈希表在“两数之和”类问题中的标准解法：**遍历时先检查 complement 是否存在，不存在再将当前元素加入 map**，避免自身重复使用。  
  - 已整理笔记：([加一](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E5%8A%A0%E4%B8%80.md))、([移动零](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E7%A7%BB%E5%8A%A8%E9%9B%B6.md))、([两数之和](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md))

- **明日计划**：  
  - 手写三题（66, 283, 1）的 C++ 实现，重点默写双指针与哈希表逻辑  
  - 复习今日错点：进位边界、快慢指针分工、map 查询与插入时机  
  - 开始 Day 4：（36.有效的数独、48.旋转图像、344.反转字符串）  

--- 
### Day 4 - 矩阵操作与字符串基础  
- **完成题目**：  
  - [x] [36] 有效的数独  
  - [x] [48] 旋转图像  
  - [x] [344] 反转字符串  

- **学习重点**：  
  - 掌握利用**三维布尔数组**或**哈希集合**对数独的行、列、3×3 宫格进行独立校验（题 36）  
  - 理解矩阵**顺时针旋转 90° 的两步法**：先转置（transpose），再逐行反转（题 48）  
  - 熟悉字符串原地反转的**双指针交换**模板，首尾相向移动直至相遇（题 344）  

- **卡点反思**：  
  - 题 [36] 能想到用 `row_has[i][num]` 和 `col_has[j][num]` 分别记录行和列的数字出现情况，但**卡在如何标识 3×3 宫格**。起初试图用复杂条件判断所属宫格，未意识到 `(i/3, j/3)` 可自然将 9×9 划分为 3×3 的块坐标，导致无法统一建模。  
  - 题 [48] 完全**缺乏旋转的几何直觉**，尝试直接推导新旧坐标映射关系失败，也未联想到“转置 + 反转”这一经典组合技巧，陷入硬编码坐标的误区。  
  - 题 [344] 实现顺利，但初期担心 `char` 类型交换是否需特殊处理，实则 C++ 中 `swap` 对字符完全适用，属于不必要的犹豫。  

- **收获与改进**：  
  - 明白了数独中 **3×3 子网格的索引可通过 `i/3` 和 `j/3` 整除压缩**，从而用 `sub_box[3][3][9]` 精准定位每个宫格的状态，实现 O(1) 校验。  
  - 掌握了**矩阵旋转的通用思维**：不直接硬算，而是拆解为基本操作（如转置、翻转）的组合，极大降低实现难度。  
  - 巩固了字符串原地操作的双指针模式，确认其适用于所有“对称交换”类问题，代码简洁且空间最优。  
  - **今日正式完成 LeetCode 初级算法《数组》章节全部内容**，建立起对数组边界处理、原地操作、哈希映射及矩阵变换的基本解题框架。  
  - 已整理笔记：([有效的数独](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC.md))、([旋转图像](https://github.com/Gelise436b/leetcode-notes/blob/main/array/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F.md))、
- **明日计划**：  
  - 手写三题（36, 48, 344）的 C++ 实现，重点默写宫格索引计算、矩阵转置+反转流程、字符串双指针交换  
  - 复习今日核心技巧：`i/3, j/3` 宫格划分、矩阵旋转的两步法、原地反转模板  
  - 开始 Day 5：继续 LeetCode 初级算法 —— 字符串专题（7.整数反转、387. 字符串中的第一个唯一字符、242. 有效的字母异位词、）
### Day 5 - 字符串处理与整数边界  
- **完成题目**：  
  - [x] [7] 整数反转  
  - [x] [387] 字符串中的第一个唯一字符  
  - [x] [242] 有效的字母异位词  

- **学习重点**：  
  - 掌握**整数反转时的溢出判断技巧**（题 7）：在每次更新结果前，通过 `res > INT_MAX / 10` 或 `res < INT_MIN / 10` 预判是否越界，避免直接计算导致未定义行为。  
  - 学会使用 **`unordered_map` + `string::find()` 结合迭代器比较** 的方式定位唯一字符（题 387），理解 `s.find(c) == s.rfind(c)` 或 `map.count(c) == 1 && first_occurrence == last_occurrence` 等等价思路。  
  - 理解**字母异位词（Anagram）** 的定义：两个字符串包含**完全相同的字符及其频次**，仅顺序不同（如 "listen" 与 "silent"）。验证方法通常为**字符频次统计**或**排序后比较**（题 242）。  

- **卡点反思**：  
  - 题 [242] 虽能写出正确代码（如用哈希表统计频次），但**初始不理解“字母异位词”的确切含义**，反映出对基础术语掌握不足，影响问题建模速度。  
  - 题 [387] 最初仅想到两次遍历计数+再遍历找首个频次为1的字符，**未意识到可利用 `find` 与 `rfind` 返回位置是否相等来直接判断唯一性**，新方法更简洁且无需额外存储频次。  
  - 题 [7] 在处理负数和末尾零时逻辑稍显混乱，初期未统一用 `long` 或提前截断，导致边界测试用例（如 `1534236469`）失败。  

- **收获与改进**：  
  - 明确了**字母异位词 = 字符组成完全一致（频次相同）**，今后遇到类似描述可快速联想到频次哈希或排序策略。  
  - 掌握了**利用字符串查找函数判断字符唯一性**的新技巧：若 `s.find(c) == s.rfind(c)`，说明该字符仅出现一次，适用于首个唯一字符类问题。  
  - 巩固了**整数操作中的防溢出意识**，学会在循环体内做“预检查”而非事后判断，提升代码鲁棒性。  
  - 初步建立起字符串问题的两大核心思路：**频次统计（哈希）** 与 **顺序无关化（排序）**，为后续字符串专题打下基础。  

- **明日计划**：  
  - 手写三题（7, 387, 242）的 C++ 实现，重点默写溢出判断条件、`find/rfind` 唯一性判断、异位词的哈希/排序两种解法  
  - 复习今日核心概念：字母异位词定义、整数反转防溢出模板、字符串唯一字符的多种判定方式  
  - 开始 Day 6：继续 LeetCode 初级算法 —— 字符串专题（125. 验证回文串、88. 字符串转换整数、28.找出字符串中第一个匹配的下标）
 
    明白了！以下是根据你提供的原始内容，整理润色后的 **Day 6 学习总结**，延续 Day 5 的风格与结构：

---

### Day 6 - 字符串处理进阶与边界细节  
- **完成题目**：  
  - [x] [125] 验证回文串  
  - [x] [8] 字符串转换整数（atoi）  
  - [x] [28] 找出字符串中第一个匹配项的下标  

- **学习重点**：  
  - 掌握**回文串验证的标准处理流程**（题 125）：忽略非字母数字字符、统一大小写后使用双指针比对。关键工具函数 `isalnum()` 可高效判断字符是否为字母或数字，避免手动枚举字符范围。  
  - 理解 **`atoi` 实现中的状态机思维**（题 8）：依次处理前导空格 → 符号位 → 数字部分 → 溢出截断。需注意不能依赖 `isdigit` 或 `isalnum` 过度简化逻辑，而应严格按题意分阶段解析。  
  - 初步接触**字符串匹配的两种策略**（题 28）：  
    - 简洁解法：直接调用 `haystack.find(needle)`；  
    - 高效解法：KMP 算法（当前尚未掌握，需后续专项学习）。  

- **卡点反思**：  
  - 题 [125] **未第一时间想到使用 `isalnum()`**，试图手动判断 `'a'-'z'`、`'A'-'Z'`、`'0'-'9'`，导致代码冗长且易漏边界（如大写转小写不彻底），反映出对 C++ 标准库字符处理函数不熟悉。  
  - 题 [8] 在解析数字时**错误尝试用 `isalnum` 辅助判断**，混淆了“字母数字”与“纯数字”的区别（例如 `'a'` 是 alnum 但不是 digit），导致逻辑混乱。正确做法应使用 `isdigit` 或直接比较 `'0' <= c <= '9'`。  
  - 题 [28] **完全依赖 `find()` 取巧通过**，对 KMP 算法原理一无所知，暴露出在“不调库”场景下的算法能力短板，尤其在面试要求手写匹配逻辑时会陷入被动。  

- **收获与改进**：  
  - 明确了 **C++ 字符分类函数的适用场景**：  
    - `isalnum(c)`：判断是否为字母或数字（用于回文过滤）；  
    - `isdigit(c)`：仅判断是否为数字（用于 atoi 解析）；  
    - `tolower(c)/toupper(c)`：安全进行大小写转换。  
  - 意识到 **复杂字符串解析题需分阶段建模**（如 atoi 的“跳空格→读符号→累加数字→防溢出”四步），避免试图一步到位。  
  - 认清了 **KMP 是字符串匹配的核心算法之一**，虽可暂时用库函数过关，但必须列入后续重点攻克清单。
  - 已整理笔记([验证回文串](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.md)),([字符串转换整数](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0.md)),([找出字符串中第一个匹配的下标项](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.md))

- **明日计划**：  
  - **手写重做今日三题（125, 8, 28）**，重点练习：  
    - 使用 `isalnum + tolower` 实现干净的回文判断；  
    - 不依赖任何转换函数，手动实现 atoi 的完整状态逻辑；  
    - 尝试写出暴力版 strStr（双层循环），并初步阅读 KMP 原理。  
  - **推进 LeetCode 初级算法新题**：  
    - [38] 外观数列  
    - [14] 最长公共前缀  
    - [237] 删除链表中的节点（注意：此题为“伪删除”，仅给定待删节点指针）  
  - 复习字符处理标准库函数，整理常用 API 速查表。

---
### Day 7 - 字符串收官与链表初探  
- **完成题目**：  
  - [x] [38] 外观数列  
  - [x] [14] 最长公共前缀（至此完成 LeetCode 初级算法 · 字符串全部题目）  
  - [x] [237] 删除链表中的节点  

- **学习重点**：  
  - 掌握**外观数列的递归建模思路**（题 38）：理解 `countAndSay(n)` 依赖于 `countAndSay(n-1)` 的返回结果，将问题拆解为“先拿到上一层描述字符串，再对其进行连续字符计数与拼接”。关键在于接受递归的“黑盒”思想——不必深究每层调用细节，只需相信前一层能正确返回所需字符串。  
  - 熟悉**最长公共前缀的矩阵视角**（题 14）：将字符串数组视为字符矩阵，逐列比对所有行在该列的字符是否一致。一旦某列出现不匹配或到达某字符串末尾，即终止并返回当前前缀。这种“垂直扫描”策略简洁高效，优于横向两两比较。  
  - 理解**链表“伪删除”的实现本质**（题 237）：题目仅提供待删节点指针，无法访问前驱。解决方案是**将下一节点的内容拷贝到当前节点**，再跳过下一节点。核心操作为 `*node = *(node->next)`（C++）或等价的字段赋值（如 `val` 和 `next` 分别覆盖），而非简单移动指针。  

- **卡点反思**：  
  - 题 [38] **递归思维未建立**：卡在无法想象 `string previous = countAndSay(n - 1)` 的具体返回形态，导致无法在此基础上进行字符遍历与计数拼接。反映出对递归“自顶向下分解、自底向上构建”的过程缺乏直觉。  
  - 题 [14] **缺乏结构化视角**：未将字符串数组抽象为二维字符矩阵，执着于逐字符串两两求交集，逻辑复杂且易错。未能第一时间想到“按列统一检查”这一更优策略。  
  - 题 [237] **混淆指针与解引用语义**：错误地写成 `node = node->next`，这只是局部指针变量重定向，并未修改原链表结构；正确做法需通过 `*node = *(node->next)` 覆盖当前节点内容（或分别赋值 `val` 和 `next`），真正实现“值覆盖式删除”。  

- **收获与改进**：  
  - 明确了**递归函数设计的关键信任原则**：只要 base case 正确、递推关系清晰，就应相信子调用能返回正确结果，专注当前层的处理逻辑。  
  - 强化了**多字符串处理的“矩阵化”思维**：对于涉及多个等长/变长字符串的公共操作（如前缀、列对齐），尝试将其视为二维结构，常能简化问题。  
  - 深刻认识到**链表操作中“修改节点内容”与“修改指针指向”的区别**：尤其在受限条件下（如无前驱指针），需灵活运用值拷贝实现逻辑删除。  
  - 已完成 LeetCode 初级算法 · 字符串模块全部内容，标志着字符串基础处理能力初步成型。
  - 已整理笔记([外观数列](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97.md)),([最长公共前缀](https://github.com/Gelise436b/leetcode-notes/blob/main/string/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.md))

- **明日计划**：  
  - **复习今日三题（38, 14, 237）**，重点练习：  
    - 手写外观数列的迭代与递归两种实现，强化递归建模能力；  
    - 实现最长公共前缀的“垂直扫描”法，并对比横向方法的差异；  
    - 重做 237 题，确保理解 `*node = *(node->next)` 的内存含义。  
  - **回顾 Day 6 的 KMP 相关内容**：重读 [28] 题笔记，尝试手写暴力版 `strStr`，并初步理解 KMP 的 next 数组思想。  
  - **推进 LeetCode 初级算法 · 链表部分**：  
    - [19] 删除链表的倒数第 N 个节点  
    - [206] 反转链表  
    - [21] 合并两个有序链表
