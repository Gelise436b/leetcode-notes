
---

# [283] 移动零

## 🧠 题目描述
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组末尾，同时保持非零元素的**相对顺序**。  
要求：**原地操作**（in-place），尽量减少操作次数。

**示例**：
- 输入：`[0,1,0,3,12]` → 输出：`[1,3,12,0,0]`

---

## 💡 核心思路

本题的关键在于**保留非零元素的原始顺序**，并将它们“紧凑”地放到前面，后面补零。

### 方法：快慢指针（或“覆盖 + 填零”）
- 使用一个指针 `stacksize`（相当于慢指针）记录**下一个非零元素应放置的位置**。
- 遍历数组（快指针）：
  - 遇到非零元素，就将其写入 `nums[stacksize]`，然后 `stacksize++`。
- 遍历结束后，从 `stacksize` 到末尾全部填充为 `0`。

> ✅ 虽未显式使用两个 `for` 循环指针，但本质是**单次遍历 + 后置填零**，等价于双指针思想。

---

## 🧪 解法代码（C++）

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int stacksize = 0; // 指向下一个非零元素应存放的位置
        
        // 第一步：将所有非零元素按顺序移到前面
        for (int x : nums) {
            if (x != 0) {
                nums[stacksize++] = x;
            }
        }
        
        // 第二步：后面的位置全部置为0
        fill(nums.begin() + stacksize, nums.end(), 0);
    }
};
```

---

## 🔍 复杂度分析
- **时间复杂度**：O(n)，仅遍历一次数组 + 一次填零（填零最多 n 次，总体仍是 O(n)）。
- **空间复杂度**：O(1)，原地修改，仅用常数额外空间。

---

## ❗ 易错点 & 反思
- ❌ 初期尝试交换 `0` 和非零元素：容易打乱非零元素的相对顺序，且逻辑复杂。
- ❌ 想用额外数组存储非零元素再复制回来：违反“原地操作”要求。
- ✅ **关键洞察**：非零元素的顺序不变 → 可直接按出现顺序“覆盖”到前面。
- ✅ `stacksize` 本质上就是**慢指针**，记录已处理的非零元素个数，也是下一个写入位置。

> 📌 此方法虽然没有显式的 `left`/`right` 双指针变量，但思想完全一致：**快指针扫描，慢指针写入**。

---

## 🔄 对比：标准双指针写法（参考）
```cpp
void moveZeroes(vector<int>& nums) {
    int slow = 0;
    for (int fast = 0; fast < nums.size(); fast++) {
        if (nums[fast] != 0) {
            swap(nums[slow++], nums[fast]); // 或直接赋值
        }
    }
}
```
> 两种写法各有优劣：你的写法更简洁、避免无意义交换；标准写法更体现“双指针”动态过程。

---

## 📌 总结
> “移动零”问题的本质是**过滤并重排**。  
> 利用一个指针记录有效元素位置，先紧凑排列非零项，再统一补零，既高效又清晰。  
> 这是**双指针思想在“元素过滤”类问题中的经典应用**。

---
