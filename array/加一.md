
---

# [66] 加一

## 🧠 题目描述
给定一个由整数组成的非空数组 `digits`，表示一个非负整数（高位在前）。  
要求：将这个整数加 1，并以相同形式返回结果数组。

**示例**：
- 输入：`[1,2,3]` → 输出：`[1,2,4]`
- 输入：`[9,9,9]` → 输出：`[1,0,0,0]`

---

## 💡 核心思路

本题本质是**模拟十进制加法中的“+1”操作**，关键在于处理**进位（carry）**。

### 关键观察：
- 从**最低位（数组末尾）开始遍历**。
- 如果当前位 `< 9`，直接 +1 并返回，**无需进位**。
- 如果当前位 `== 9`，则变为 `0`，继续向高位进位。
- 若所有位都是 `9`（如 `[9,9,9]`），最终会**产生新最高位 1**，结果长度 +1。

> ✅ **无需显式维护 carry 变量**：因为只加 1，进位最多传播一次，遇到非 9 就终止。

---

## 🧪 解法代码（C++）

```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        // 从最后一位开始向前遍历
        for (int i = digits.size() - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i]++;      // 直接加1，无进位，结束
                return digits;
            }
            digits[i] = 0;        // 当前位是9，变为0，继续进位
        }
        
        // 走到这里说明全是9，如 [9,9,9]
        digits.push_back(0);      // 扩容一位（末尾加0）
        digits[0] = 1;            // 首位设为1 → [1,0,0,0]
        return digits;
    }
};
```

---

## 🔍 复杂度分析
- **时间复杂度**：O(n)，最坏情况遍历整个数组（全为9）。
- **空间复杂度**：O(1)（不计输出空间），原地修改；仅当全为9时需扩容，但属于必要输出。

---

## ❗ 易错点 & 反思
- ❌ 初期试图用 `int` 转换整个数组再 +1：**会溢出**（数字可能极大）。
- ❌ 想复杂了进位逻辑：其实只需判断是否 `<9`，无需 carry 标志。
- ✅ **技巧**：全为9的情况，等价于 `[1] + n个0`，可通过 `push_back(0)` + `digits[0]=1` 高效构造。

---

## 📌 总结
> “加一”问题的核心是**逆序处理 + 进位终止条件**。  
> 遇到 9 变 0 继续，遇到非 9 直接 +1 返回。  
> 全 9 是唯一需要扩容的特殊情况，巧妙利用 `push_back` 和首位置 1 即可。

---
