
---

### 📝 题目：[48] 旋转图像 —— 从无思路到掌握经典两步法  

**原始困境**：  
面对“原地顺时针旋转 90°”的要求，**完全无法建立坐标变换的直观模型**。尝试直接推导 `matrix[i][j] → matrix[j][n-1-i]` 的映射关系，但因涉及多轮覆盖与临时存储，逻辑混乱且难以实现原地操作。

**关键突破**：  
✅ **将复杂旋转拆解为两个简单操作**：  
1. **矩阵转置（transpose）**：沿主对角线翻转，即交换 `matrix[i][j]` 与 `matrix[j][i]`（仅遍历下三角避免重复）；  
2. **每行反转（reverse each row）**：将每行元素顺序倒置。  

二者组合效果 = 顺时针旋转 90°！

**示例验证**：
```
原始：       转置后：      行反转后（结果）：
1 2 3       1 4 7        7 4 1
4 5 6   →   2 5 8    →   8 5 2
7 8 9       3 6 9        9 6 3
```

**实现亮点**：  
- 转置用双层循环 `j < i` 确保只处理下三角，避免来回交换；  
- 使用 `ranges::reverse(row)`（C++20）或 `std::reverse` 高效完成行反转；  
- **全程原地操作，空间复杂度 O(1)，时间复杂度 O(n²)**，极致简洁。

**经验提炼**：  
> **面对几何变换类问题，优先考虑“分解为基本操作”**（如翻转、转置、镜像），而非硬推坐标公式。  
> “转置 + 反转”是矩阵旋转的经典范式，值得牢记并迁移至类似场景（如图像处理、游戏开发）。

---
