太棒了！你已经抓住了异或解法的精髓。以下是根据你提供的内容整理后的 **136. 只出现一次的数字** 规范学习笔记，风格与你的 LeetCode 笔记项目统一，重点突出、便于复习：

---

# [136] 只出现一次的数字

## 📌 题目简述
给定一个非空整数数组 `nums`，其中**每个元素都出现两次，只有一个元素只出现一次**。  
找出并返回那个**只出现一次的元素**。

> 要求：算法应具有线性时间复杂度，且**不使用额外空间**（即 O(1) 空间）。

---

## 💡 解题思路对比

### 方法一：哈希表计数（初始解法）
- 使用 `map<int, int>` 统计每个数字出现次数；
- 再遍历 map 找出频次为 1 的数字。
- ✅ 正确，但 ❌ 不满足“不使用额外空间”的隐含要求。

```cpp
// 时间 O(n)，空间 O(n)
unordered_map<int, int> cnt;
for (int x : nums) cnt[x]++;
for (auto& [k, v] : cnt) if (v == 1) return k;
```

### 方法二：异或运算（最优解）
利用异或（XOR）的两个核心性质：
1. **自反性**：`a ^ a = 0`
2. **零元性**：`a ^ 0 = a`

由于所有成对数字异或后抵消为 0，最终结果即为落单数字：
```
a ^ b ^ a ^ c ^ b = (a ^ a) ^ (b ^ b) ^ c = 0 ^ 0 ^ c = c
```

✅ 仅需**一次遍历**，**O(1) 空间**，完美符合题目要求！

---

## 💻 代码实现（异或解法）

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int x = 0;
        for (int num : nums) {
            x ^= num; // 成对抵消，留下唯一数
        }
        return x;
    }
};
```

---

## ⏱️ 复杂度分析
- **时间复杂度**：O(n)，仅遍历一次数组；
- **空间复杂度**：O(1)，仅用一个变量 `x`。

---

## 🧠 关键收获
- **异或运算是解决“唯一出现”问题的利器**，尤其适用于“其余元素均成对出现”的场景。
- 不必关心中间过程值，因为异或满足**交换律与结合律**，顺序无关。
- 初学时容易陷入“必须记录状态”的思维定式，而忽略位运算的巧妙性。

---

## 🔜 延伸思考
- 若有两个数字只出现一次，其余都出现两次？→ 需结合分组异或（LeetCode 260）。
- 异或还可用于：交换两个数（无需临时变量）、判断奇偶校验等。

---

> 📝 **复习建议**：默写异或解法，并能口述其数学原理；对比哈希 vs 位运算的时空差异。

---
