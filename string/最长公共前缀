
---

### [14] 最长公共前缀 —— 列扫描（垂直比较）策略

#### 🔍 核心问题
- **思维盲区**：未将字符串数组 `vector<string>& strs` 视为一个“字符矩阵”，导致未能想到**按列逐位比较**的解法。
- 初期尝试横向两两比较前缀（如先比 str[0] 和 str[1]，再与 str[2] 比……），逻辑复杂且效率低，容易出错。

#### ✅ 正确解法：垂直扫描（列优先）
```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string& s0 = strs[0]; // 以第一个字符串为基准
        for (int j = 0; j < s0.size(); j++) {          // 遍历每一列（即每个字符位置）
            for (string& s : strs) {                   // 遍历所有字符串（即该列的每一行）
                if (j == s.size() || s0[j] != s[j]) {  // 越界 或 字符不匹配
                    return s0.substr(0, j);            // 返回 [0, j) 的前缀
                }
            }
        }
        return strs[0]; // 所有字符都匹配，返回整个首字符串
    }
};
```

#### 🧠 关键理解点
1. **“字符矩阵”视角**  
   将输入看作如下结构（以 `["flower","flow","flight"]` 为例）：
   ```
   f l o w e r
   f l o w
   f l i g h t
   ```
   - **行** = 每个字符串  
   - **列** = 所有字符串在相同位置的字符  
   公共前缀就是从第 0 列开始，连续匹配的列数。

2. **外层循环控制“列”（j），内层循环遍历“行”（每个字符串）**  
   - 对每一列 `j`，检查所有字符串在该位置是否等于 `strs[0][j]`。
   - 一旦发现某个字符串长度不足（`j == s.size()`）或字符不同（`s0[j] != s[j]`），立即终止。

3. **边界处理自然优雅**  
   - 空字符串会直接在 `j=0` 时触发 `j == s.size()`，返回空串。
   - 若所有列都匹配到底，说明首字符串就是最长公共前缀。

#### 💡 为什么列扫描优于横向比较？
| 方法 | 时间复杂度 | 逻辑复杂度 | 优势 |
|------|------------|------------|------|
| 横向两两比较 | O(S)，S 为总字符数 | 高（需维护中间前缀） | 直观但冗余 |
| **垂直扫描（列）** | **O(S)** | **极低（单层嵌套）** | **简洁、高效、边界清晰** |

> 注：两种方法时间复杂度相同，但垂直扫描代码更短、更易写对。

#### 📌 反思与改进
- 遇到“多个字符串的公共部分”问题，**优先考虑垂直/列视角**。
- 不必拘泥于“先求两个的前缀”，整体结构思维往往更优。
- 把字符串数组想象成二维网格，是处理此类问题的重要建模技巧。

--- 
