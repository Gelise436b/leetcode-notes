

---

### 📌 LeetCode 101：对称二叉树（Symmetric Tree）

#### 🔍 核心思想  
一棵二叉树对称 ⇨ **其左子树与右子树互为镜像**。  
镜像的定义是：
- 两棵树的根节点值相等；
- **左子树的左子树** 与 **右子树的右子树** 对称；
- **左子树的右子树** 与 **右子树的左子树** 对称。

> ✨ 关键洞察：**对称 ≠ 左右子树结构相同，而是“外侧对齐 + 内侧对齐”的交叉对应关系**。

---

### ❌ 初始误区
- 仅检查 `root->left->val == root->right->val`，忽略了子树间的**镜像配对逻辑**；
- 未意识到需同时递归比较：
  - `left->left` 与 `right->right`（外侧）
  - `left->right` 与 `right->left`（内侧）

这导致在如下结构中误判：
```
    1
   / \
  2   2
   \ /
   3 3   ← 外侧不对称，但若只比根左右会漏判
```

---

### ✅ 正确解法：双指针递归（镜像判断）

```cpp
class Solution {
    bool isMirror(TreeNode* left, TreeNode* right) {
        // 边界1：两者都为空 → 对称
        if (!left && !right) return true;
        // 边界2：一个为空一个非空 → 不对称
        if (!left || !right) return false;
        // 当前层：值相等 + 外侧对称 + 内侧对称
        return (left->val == right->val)
            && isMirror(left->left,  right->right)  // 外侧
            && isMirror(left->right, right->left);  // 内侧
    }

public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return isMirror(root->left, root->right);
    }
};
```

---

### 🧠 解题要点总结

| 要素 | 说明 |
|------|------|
| **递归对象** | 不是单棵树，而是**两棵树是否互为镜像** |
| **边界条件** | 1. 双空 → true；2. 单空 → false |
| **当前层逻辑** | 值相等 + 递归检查 `(左左, 右右)` 和 `(左右, 右左)` |
| **思维转换** | 将“整棵树是否对称”转化为“左右子树是否镜像” |

---

### 💡 启示与反思

- **树的结构性问题常需“双指针”视角**：单指针递归适用于路径、深度等问题，而**关系类问题（对称、相同、翻转）往往需要同时遍历两个节点**。
- **边界条件即正确性基石**：空指针的处理不仅防崩溃，更是逻辑完备性的体现。
- **递归设计口诀**：  
  > “**一拆二，二比三，三看边界与当前**”  
  > —— 拆成两个子问题，比较三个要素（值、外侧、内侧），边界先行，当前层收尾。

---

> ✨ **一句话总结**：  
> **对称二叉树 = 镜像递归 + 双指针同步 + 外内交叉比对**
