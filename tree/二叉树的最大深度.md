
---

# [104] 二叉树的最大深度

## 🎯 题目要求
给定一个二叉树，找出其**最大深度**（从根节点到最远叶子节点的最长路径上的节点数）。

---

## ✅ 两种经典解法：DFS 与 BFS

### 方法一：DFS（深度优先搜索）—— 递归后序遍历（推荐）
```cpp
int maxDepth(TreeNode* root) {
    if (!root) return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return std::max(left, right) + 1;
}
```
- **思想**：树的最大深度 = `max(左子树深度, 右子树深度) + 1`；
- **本质**：自底向上的后序遍历，天然契合“子问题分解”；
- **时间复杂度**：O(n)，每个节点访问一次；  
- **空间复杂度**：O(h)，h 为树高（递归栈深度），最坏 O(n)（退化为链表）。

---

### 方法二：BFS（广度优先搜索）—— 层序遍历（迭代）
```cpp
int maxDepth(TreeNode* root) {
    if (!root) return 0;
    vector<TreeNode*> que;
    que.push_back(root);
    int res = 0;
    while (!que.empty()) {
        vector<TreeNode*> tmp;
        for (TreeNode* node : que) {
            if (node->left) tmp.push_back(node->left);
            if (node->right) tmp.push_back(node->right);
        }
        que = tmp;  // 进入下一层
        res++;      // 每完成一层，深度 +1
    }
    return res;
}
```
> ✅ 注意：`que = tmp` 和 `res++` 必须在 **for 循环外部**，确保按层推进。

- **思想**：逐层遍历，每处理完一层，深度加一；
- **时间复杂度**：O(n)；  
- **空间复杂度**：O(w)，w 为树的最大宽度（最坏 O(n)）。

> 💡 更高效写法：使用 `queue<TreeNode*>` 避免 vector 拷贝，但逻辑等价。

---

## 🔍 DFS vs BFS 对比

| 维度 | DFS（递归） | BFS（层序） |
|------|-------------|-------------|
| **实现难度** | ⭐ 极简（3 行核心） | ⭐⭐ 需维护层状态 |
| **空间开销** | 递归栈（依赖树高） | 队列/容器（依赖层宽） |
| **适用场景** | 求深度、路径、回溯 | 求层序、最小深度、按层操作 |
| **思维模式** | “分治”、“自底向上” | “逐层推进”、“广度扩展” |

> 📌 **本题首选 DFS**：代码简洁、逻辑清晰、无额外容器开销。

---

## 🧠 反思与教训

| 问题 | 根源 | 改进措施 |
|------|------|----------|
| 忘记 DFS/BFS 经典解法 | 数据结构基础不牢固，缺乏定期回顾 | 建立“遍历模板库”：DFS（前/中/后序）、BFS（层序）必须能 10 秒内默写 |
| BFS 实现曾出错（循环内更新队列） | 对“按层处理”逻辑理解模糊 | 牢记口诀：**“先遍历当前层 → 再统一进下一层 → 最后深度+1”** |
| 未意识到这是树遍历的“Hello World” | 对基础题重视不足 | 初级题是高频面试题！务必做到“看到题型秒出模板” |

---

## 💡 总结

- **DFS 是本题最优解**：体现递归之美，代码即逻辑；
- **BFS 是通用层序工具**：为后续“层序遍历”“右视图”“层平均值”等题打基础；
- **树的核心 = 遍历 + 递归**，必须将 DFS/BFS 内化为本能反应；
- 此题是**树章节的起点**，务必夯实，后续所有树问题（验证、构造、路径）都建立在此之上。

> 📌 **一句话口诀**：  
> **“求深度用 DFS，看层级用 BFS；递归三行解，层序队列推。”**

---
