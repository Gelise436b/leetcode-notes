
---

# [108] 将有序数组转换为二叉搜索树

## 📌 题目描述
给定一个按 **升序排列** 的整数数组 `nums`，将其转换为一棵 **高度平衡的二叉搜索树（BST）**。  
> 高度平衡：每个节点的左右子树高度差不超过 1。

---

## ✅ 解题思路

### 核心观察
- 有序数组 ⇨ BST 的 **中序遍历结果**
- 要构造**高度平衡**的 BST ⇒ 每次选择**中间元素作为根节点**
- 左半部分递归构建左子树，右半部分递归构建右子树  
  → 典型的 **分治 + 递归** 思想

### 为什么取中点？
- 中点作为根，能保证左右子树节点数尽可能相等
- 递归下去，自然满足“高度平衡”要求

---

## 🔧 实现细节

### 递归函数设计
```cpp
TreeNode* dfs(vector<int>& nums, int left, int right)
```
- **参数含义**：在 `nums[left, right)` 区间内构造 BST（左闭右开）
- **递归基**：`if (left == right) return nullptr;`（空区间）
- **中点计算**：`int m = left + (right - left) / 2;`  
  → 避免 `(left + right) / 2` 可能溢出（虽在本题中不会，但为良好习惯）

### 构造方式
直接使用 `TreeNode` 的三参数构造函数：
```cpp
new TreeNode(nums[m], dfs(nums, left, m), dfs(nums, m + 1, right));
```
- 根值：`nums[m]`
- 左子树：`[left, m)`
- 右子树：`[m+1, right)`

### 主函数调用
```cpp
return dfs(nums, 0, nums.size()); // 使用左闭右开区间
```

> 💡 使用 **左闭右开区间 `[left, right)`** 是 C++ STL 的惯用法，边界处理更清晰，避免 `<=` 与 `<` 混淆。

---

## ⚠️ 卡点反思

- **误区**：试图通过“切片”传递子数组（如 `vector<int> sub = ...`）  
  → 导致大量拷贝，效率低且难以控制索引。
- **正解**：**只传递原数组引用 + 索引范围**，轻量高效。
- **关键认知**：递归的状态由 **输入范围** 定义，而非数据本身。

---

## 🧠 学习收获

1. **分治建模能力提升**：将“构造平衡 BST”问题转化为“选中点 + 递归左右”的标准模式。
2. **递归状态设计原则**：用 **索引区间** 表示子问题，避免数据复制。
3. **区间表示习惯**：左闭右开 `[left, right)` 更利于边界统一（如 `size()` 直接作为右端点）。
4. **构造函数巧用**：C++ 中可直接在 `new` 时完成左右子树赋值，代码简洁。

---

## 📎 扩展思考

- 若数组长度为偶数，取左中点 or 右中点？  
  → 本题任选其一均可（都满足高度平衡），代码中 `m = left + (right-left)/2` 取的是**左中位数**。
- 此方法构造的 BST 是**唯一**的吗？  
  → 不唯一！但所有解都是高度平衡的 BST。

---

## ✍️ 默写模板（推荐记忆）

```cpp
TreeNode* dfs(vector<int>& nums, int l, int r) {
    if (l == r) return nullptr;
    int m = l + (r - l) / 2;
    return new TreeNode(nums[m], dfs(nums, l, m), dfs(nums, m + 1, r));
}

TreeNode* sortedArrayToBST(vector<int>& nums) {
    return dfs(nums, 0, nums.size());
}
```

---

> 📚 **关联知识**：二分查找、中序遍历、分治算法、递归设计  
> 🔄 **后续可练**：[109] 有序链表转换二叉搜索树（进阶版，需找中点）

--- 
