

---

### 📌 LeetCode 98：验证二叉搜索树（Validate Binary Search Tree）

#### 🔍 核心思想  
BST 的定义要求：**任意节点的左子树所有值 < 当前值 < 右子树所有值**。  
验证的关键在于 **将全局约束转化为局部可检查的条件**，而不同遍历策略提供了三种等价但视角各异的实现路径。

---

### ✅ 三种解法对比

| 遍历方式 | 思路                                                                 | 时间复杂度 | 空间复杂度 | 特点 |
|----------|----------------------------------------------------------------------|------------|------------|------|
| **前序遍历** | 自顶向下传递**有效值区间** `[left, right]`，当前节点必须在此区间内       | O(n)       | O(h)       | 逻辑直观，无需全局变量 |
| **中序遍历** | 利用 BST 中序遍历为**严格递增序列**的性质，维护前驱值 `pre` 进行比较     | O(n)       | O(h)       | 最简洁，体现 BST 本质 |
| **后序遍历** | 自底向上返回子树的 `[min, max]`，当前节点需满足 `l_max < x < r_min`    | O(n)       | O(h)       | 纯函数式，无副作用 |

---

### 💡 解法详解

#### 1️⃣ 前序遍历（区间约束法）
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root, long long left = LLONG_MIN, long long right = LLONG_MAX) {
        if (!root) return true;
        long long x = root->val;
        return (left < x && x < right)                    // 当前节点合法
            && isValidBST(root->left, left, x)            // 左子树区间: (left, x)
            && isValidBST(root->right, x, right);         // 右子树区间: (x, right)
    }
};
```
- ✅ **优点**：无需额外状态，天然支持递归；
- ⚠️ **注意**：边界需用 `long long` 避免 `INT_MIN/MAX` 冲突。

---

#### 2️⃣ 中序遍历（单调性验证）
```cpp
class Solution {
    long long pre = LLONG_MIN;
public:
    bool isValidBST(TreeNode* root) {
        if (!root) return true;
        if (!isValidBST(root->left)) return false;   // 左
        if (root->val <= pre) return false;          // 中：检查是否破坏递增
        pre = root->val;
        return isValidBST(root->right);              // 右
    }
};
```
- ✅ **优点**：代码最简，直接利用 BST 定义性质；
- ⚠️ **关键**：必须是 **严格递增**（`<=` 即非法）。

---

#### 3️⃣ 后序遍历（子树范围回传）
```cpp
class Solution {
    pair<long long, long long> dfs(TreeNode* node) {
        if (!node) return {LLONG_MAX, LLONG_MIN};    // 空树：min=+∞, max=-∞
        auto [l_min, l_max] = dfs(node->left);
        auto [r_min, r_max] = dfs(node->right);
        long long x = node->val;
        if (x <= l_max || x >= r_min)                // 不满足 BST 条件
            return {LLONG_MIN, LLONG_MAX};           // 返回错误哨兵
        return {min(l_min, x), max(r_max, x)};       // 返回当前子树范围
    }
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root).second != LLONG_MAX;
    }
};
```
- ✅ **优点**：无全局状态，适合并发或函数式风格；
- ⚠️ **技巧**：用 `{LLONG_MIN, LLONG_MAX}` 作为非法标记。

---

### 🧠 反思与启示

- **递归的本质是“信任”**：只需明确 **边界条件**（空节点）和 **当前层逻辑**（如何利用子问题结果），无需深究调用细节。
- **遍历方式决定解题视角**：
  - 前序 → **自顶向下约束传递**
  - 中序 → **线性序列性质利用**
  - 后序 → **自底向上信息聚合**
- **避免过度设计**：初期因混淆遍历顺序而试图强行套用复杂逻辑，实则每种方法都只需关注**局部合法性**。

> ✨ **一句话总结**：  
> **BST 验证 = 选对遍历 + 局部校验 + 边界处理**

---
