
---

### 📝 [384] 打乱数组 —— 均匀洗牌与工程封装的双重考验

#### 🔍 题目核心
> 设计一个类 `Solution`，支持：
> - `reset()`：返回原始数组；
> - `shuffle()`：返回一个**等概率随机打乱**的数组副本。  
> 要求：**所有排列出现概率严格相等**，且多次调用互不影响。

**关键挑战**：  
1. **数学正确性**：如何保证均匀性？  
2. **工程完整性**：如何设计类结构以满足接口契约？

---

#### 💡 正确解法：Fisher-Yates 洗牌（Knuth Shuffle）

##### ✅ 算法流程
```cpp
vector<int> shuffle() {
    vector<int> nums(original); // 每次操作独立副本
    for (int i = nums.size() - 1; i >= 0; i--) {
        int j = rand() % (i + 1); // j ∈ [0, i]
        swap(nums[i], nums[j]);
    }
    return nums;
}
```

##### ✅ 为何能保证“不重复”且“均匀”？
> **澄清误区**：  
> ❌ “算法要避免选到重复元素” → **错误！**  
> ✅ **目标不是“元素不重复”，而是“每个排列等概率生成”**。

- **每轮操作范围动态缩小**：
  - 第 `i` 轮：在 `[0, i]` 中随机选 `j`，将 `nums[j]` 与 `nums[i]` 交换；
  - 交换后，`nums[i]` 被**固定为最终位置**，后续不再变动；
  - 下一轮 `i--`，操作区间缩至 `[0, i-1]`。
- **即使 `rand()` 多次返回相同值（如 `j=0`）**：
  - 因数组内容随交换改变，**同一 `j` 在不同轮次指向不同元素**；
  - 每轮仅影响未固定前缀，**历史选择不影响未来分布**。
- **数学保证**：
  - 总路径数 = `n × (n−1) × ⋯ × 1 = n!`；
  - 每种排列恰好对应一条路径 → **概率 = 1/n!**。

> ✅ **“不重复”指排列唯一性（由算法结构保证），而非随机数不重复！**

##### ✅ 工程实现要点
| 组件 | 作用 |
|------|------|
| `original` 成员变量 | 保存构造时的原始数组，确保 `reset()` 永不失效 |
| `shuffle()` 返回新副本 | 避免修改内部状态，保证多次调用独立 |
| 构造函数深拷贝 | 防止外部修改 `nums` 影响 `original` |

> ⚠️ **注意**：`rand()` 存在轻微偏差（因 `RAND_MAX` 不一定是 `i+1` 的倍数），工业级应用应使用 `<random>` 库，但 LeetCode 场景可接受。

---

#### ⚠️ 常见误区与反思

| 误区 | 正确认知 |
|------|--------|
| **“随机数重复会导致元素被多次选中”** | ❌ 元素是否“被选”取决于其当前位置，而非 `j` 值；算法通过**缩小作用域**天然隔离已固定部分 |
| **直接在 `original` 上 shuffle** | ❌ 违反“多次调用独立”要求；必须操作副本 |
| **忘记保存原始数组** | ❌ 导致 `reset()` 无法还原；需在构造时深拷贝 |
| **会写洗牌逻辑，但不会封装成类** | ✅ 反映“算法思维”与“工程思维”脱节：需同步训练**接口设计、状态管理、边界处理**能力 |

---

#### 🧠 设计问题核心范式

| 维度 | 要求 |
|------|------|
| **功能正确性** | 满足题目数学/逻辑约束（如均匀洗牌） |
| **接口鲁棒性** | 方法无副作用、幂等性（如 `reset()` 永远返回初始状态） |
| **状态隔离性** | 内部数据不被外部意外修改（通过深拷贝/私有成员） |
| **复杂度合规** | 时间 O(n)，空间 O(n)（允许返回新数组） |

> ✅ **设计类题目 = 算法 + 封装 + 契约意识**

---

#### 🔗 关联知识
- **随机数生成**：`std::mt19937` + `std::uniform_int_distribution`（更优替代 `rand()`）
- **原地算法**：Fisher-Yates 是少数兼具**原地性、均匀性、线性时间**的经典算法
- **概率验证**：可通过统计大量 shuffle 结果的频率分布验证均匀性

---

#### 📌 总结
> **打乱数组的本质不是“随机交换”，而是“通过逐步固定位置构建均匀排列空间”。**  
> 本题暴露了从“片段算法”到“完整系统”的能力断层——今后需在掌握核心逻辑的同时，**主动思考：如何封装？状态如何管理？接口如何设计？**  
> Fisher-Yates 的精妙在于：**用最简操作（n 次交换）实现最强保证（n! 种排列等概率）**，是算法与数学结合的典范。

---

