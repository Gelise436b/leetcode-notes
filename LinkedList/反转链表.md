
---

### [206] 反转链表

#### 🔑 核心思路：头插法（迭代） vs 尾插法（递归）

本题考察链表反转的两种经典实现方式，本质都是通过**断开原连接、重建反向指针**完成操作。

---

##### ✅ 方法一：迭代（头插法）

- **思想**：遍历原链表，将每个节点**插入到新链表的头部**。
- **关键三步**（循环体内）：
  1. **保存下一节点**：`nxt = cur->next`（防止断链后丢失后续）
  2. **反转当前指针**：`cur->next = pre`（将当前节点接到新链表头）
  3. **更新状态**：`pre = cur; cur = nxt;`
- **初始状态**：`pre = nullptr`（新链表为空），`cur = head`
- **返回值**：`pre`（最终指向原链表尾，即新头）

```cpp
ListNode* reverseList(ListNode* head) {
    ListNode* pre = nullptr;
    ListNode* cur = head;
    while (cur) {
        ListNode* nxt = cur->next;
        cur->next = pre; // 头插：当前节点成为新头
        pre = cur;
        cur = nxt;
    }
    return pre;
}
```

---

##### ✅ 方法二：递归（尾插法）

- **思想**：  
  - **「递」**：深入到链表末尾，将最后一个节点作为新头 `rev_head`；  
  - **「归」**：回溯时，将当前节点**追加到已反转部分的末尾**（即原 `head->next` 所在位置）。
- **关键细节**：
  - `tail = head->next`：在回溯层中，`head->next` 恰好是已反转子链表的**尾节点**；
  - `tail->next = head`：将当前 `head` 接到尾部；
  - `head->next = nullptr`：**必须置空**，否则最后两个节点会形成环（如 `4 ↔ 5`）。
- **返回值**：始终返回最底层的 `rev_head`（即原链表尾）

```cpp
ListNode* reverseList(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head; // base case：末尾节点即新头
    }
    auto rev_head = reverseList(head->next); // 递：拿到新头
    ListNode* tail = head->next;             // 归：head->next 是已反转部分的尾
    tail->next = head;                       // 尾插：把 head 接到尾
    head->next = nullptr;                    // 防环：断开原连接
    return rev_head;
}
```

---

#### 💡 反思与提升

- **问题根源**：遗忘“头插法”这一基础链表操作，试图用复杂逻辑暴力拼接，导致效率低下甚至出错。
- **核心认知**：
  - **迭代更高效**（O(1) 空间，无栈溢出风险），**递归更直观**（符合“先反转后面，再处理当前”的自然思维）；
  - 无论哪种方法，**保存下一节点**和**及时断开/重连指针**是避免丢失数据或成环的关键。
- **通用原则**：  
  > 链表题 = **指针操作 + 边界控制**。熟练掌握头插、尾插、快慢指针等原子操作，是解题基石。

---

#### 📌 总结

| 方法   | 时间复杂度 | 空间复杂度 | 优点               | 注意事项         |
|--------|------------|------------|--------------------|------------------|
| 迭代   | O(n)       | O(1)       | 高效、安全         | 指针顺序不能乱   |
| 递归   | O(n)       | O(n)       | 逻辑清晰、代码简洁 | 需防环、注意栈深 |

---
