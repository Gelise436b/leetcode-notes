
---

# [234] 回文链表

## 🎯 题目要求
判断一个单链表是否为**回文链表**（正读和反读相同）。  
**进阶要求**：使用 O(1) 额外空间复杂度。

---

## ✅ 核心思路：快慢指针 + 局部反转（O(1) 空间）

> 将链表分为前后两半 → 反转后半部分 → 双指针同步比对

### 三步法：
1. **找中点**：用快慢指针定位链表中间节点（偶数时取后半段起点）；
2. **反转后半段**：从中间节点开始，原地反转链表；
3. **双指针比对**：从头节点与反转后的后半段头节点同步遍历，逐值比较。

> ⚠️ 注意：此解法**不恢复原链表**。若题目要求“不修改链表”，则需在比对后再次反转后半段以还原结构。

---

## 🔧 关键函数实现

### 1. 找中点（快慢指针）
```cpp
ListNode* middle(ListNode* head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow; // 奇数：正中；偶数：后半段第一个
}
```
- **快指针走两步，慢指针走一步** → 快指针到尾时，慢指针恰在中点。
- 对于 `1->2->2->1`，返回第二个 `2`；对于 `1->2->3`，返回 `3`。

### 2. 反转链表（迭代头插法）
```cpp
ListNode* reverseList(ListNode* head) {
    ListNode *pre = nullptr, *cur = head;
    while (cur) {
        ListNode *nxt = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nxt;
    }
    return pre; // 新头节点
}
```
- 经典三步：**保下 → 反指 → 前移**。

### 3. 主逻辑：比对
```cpp
bool isPalindrome(ListNode* head) {
    ListNode* mid = middle(head);
    ListNode* head2 = reverseList(mid);
    
    while (head2) { // 只需遍历后半段长度
        if (head->val != head2->val) return false;
        head = head->next;
        head2 = head2->next;
    }
    return true;
}
```
- **为什么只判 `head2`？**  
  后半段长度 ≤ 前半段（奇数时前半段多一个中心节点，无需比较）。

---

## 🧠 易错点 & 反思

| 问题 | 原因 | 改进 |
|------|------|------|
| 未联想到“快慢指针+反转”组合 | 将算法技巧孤立看待，缺乏模块化思维 | 建立“工具箱”意识：快慢指针（定位）、反转（重构）、双指针（比对）可自由组合 |
| 担心破坏原链表结构 | 忽略题目是否要求“不修改输入” | 默认允许修改；若不允许，比对后需再次反转后半段恢复 |
| 中点位置理解错误 | 不清楚偶数链表中点定义 | 记住：`fast` 起点与 `while` 条件决定中点位置，本题写法天然适配回文比对 |

---

## 💡 总结

- **空间最优解 = 快慢指针 + 原地反转**，是链表回文问题的黄金模板；
- 此题是 **Day 8 所学技巧（快慢指针、反转）的综合应用**，验证了“基础操作组合解决复杂问题”的能力；
- 后续遇到“链表对称性”“中间操作”类问题，优先考虑此模式。

> 📌 **一句话口诀**：  
> **“快慢找中，反转后半，双指比对，简洁高效。”**

---
