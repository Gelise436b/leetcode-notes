
---

### [237] 删除链表中的节点 —— 值覆盖式删除与指针语义辨析

#### 🔍 核心问题
- **方法思路正确**：知道不能访问前驱节点，应通过“将下一节点内容复制到当前节点”来实现逻辑删除。
- **关键错误**：混淆了 **指针赋值** 与 **解引用赋值**：
  - 错误写法：`node = node->next;`  
    → 仅改变局部指针变量 `node` 的指向，**未修改原链表中该节点的内容**，外部链表结构不变，删除无效。
  - 正确写法：`*node = *(node->next);`  
    → **解引用后赋值**，将下一节点的 `val` 和 `next` 字段完整拷贝到当前节点，真正“覆盖”了待删节点。

#### ✅ 正确解法：值覆盖 + 释放内存（C++）
```cpp
class Solution {
public:
    void deleteNode(ListNode* node) {
        auto nxt = node->next;     // 保存下一个节点
        *node = *nxt;              // 关键：将 nxt 的内容（val 和 next）拷贝到当前节点
        delete nxt;                // 释放原下一节点内存（避免泄漏）
    }
};
```

> 注：在 LeetCode 环境中，`delete nxt;` 虽非强制（测试用例不检查内存泄漏），但**良好实践应包含**。

#### 🧠 关键理解点
1. **`node` 是一个指针，`*node` 才是它指向的节点对象**  
   - `node = node->next;`：让局部变量 `node` 指向别处，不影响原链表。
   - `*node = *(node->next);`：等价于：
     ```cpp
     node->val = node->next->val;
     node->next = node->next->next;
     ```
     这才是真正的“内容覆盖”。

2. **为什么能这样“删除”？**  
   题目保证 `node` 不是尾节点，且只给出待删节点指针。  
   我们无法修改前驱的 `next`，但可以**让当前节点“变成”下一个节点**，再删掉下一个节点——从效果上看，原节点被“删除”了。

3. **内存安全（C++ 特有）**  
   手动分配的链表节点需手动释放。虽然 LeetCode 测试可能忽略 `delete`，但生产代码必须释放 `nxt`，否则内存泄漏。

#### 💡 类比理解
想象两个盒子 A 和 B：
- A 里写着 “5”，连着 B；
- B 里写着 “6”，连着 C。

你想“删掉 A”，但没人告诉你谁连着 A。  
于是你：
1. 把 B 里的 “6” 和 “指向 C” 全部抄到 A 里 → 现在 A 看起来就是 B；
2. 把原来的 B 盒子扔掉（`delete`）。

对外部观察者来说，A 已经“变成”了 B，原来的 A 内容消失了——相当于删除了 A。

#### 📌 反思与改进
- **牢记：修改链表结构 ≠ 修改指针变量**。要改的是节点内容（通过解引用）。
- 在 C/C++ 中，`*p = *q` 表示**对象拷贝**，而 `p = q` 只是**指针重定向**。
- 遇到“仅给定待删节点”的链表题，优先考虑“值覆盖”策略。

--- 
