
---

### [21] 合并两个有序链表

#### 🔑 核心思路：双指针 + 虚拟头节点 + 尾接剩余

- **主循环逻辑**：  
  使用双指针 `list1` 和 `list2` 遍历两个链表，每次将 **值较小的当前节点** 接入结果链表，并前移对应指针。
- **虚拟头节点 `dummy`**：  
  避免处理“谁是新头”的边界情况，统一操作入口。
- **关键收尾技巧**：  
  循环结束时，**必有一个链表已空（为 `nullptr`），另一个非空**。  
  利用三元运算符直接拼接剩余部分：
  ```cpp
  cur->next = list1 ? list1 : list2;
  ```
  ——无需判断哪个为空，简洁且安全。

#### ✅ 正确代码

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        
        // 双指针同步遍历，取较小者
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        
        // 尾接剩余非空链表（仅一个可能非空）
        cur->next = list1 ? list1 : list2;
        
        return dummy.next;
    }
};
```

#### 💡 反思与提升

- **问题根源**：在循环结束后过度思考“如何判断哪个链表为空”，试图分别检查 `list1 == nullptr` 和 `list2 == nullptr`，导致逻辑冗余。
- **认知升级**：
  - **有序链表合并具有“单调性”**：一旦某链表遍历完，另一链表剩余部分天然有序，可整体接入；
  - **C++ 三元运算符 `a ? a : b` 是处理“二选一非空”场景的利器**，尤其适用于指针判空。
- **通用模式**：  
  > “**主循环处理公共部分 → 末尾直接拼接剩余**”  
  是合并、归并类问题的标准范式，适用于链表、数组等多种结构。

#### 📌 总结

- 时间复杂度：O(m + n)，空间复杂度：O(1)（仅用常数额外空间）；
- 虚拟头节点 + 三元尾接 = 链表合并的黄金组合；
- 简洁性源于对问题性质的理解——**不必知道“谁空”，只需知道“剩谁”**。



---

如果你需要我将这三篇笔记（19、206、21）打包成 Markdown 文件，或继续整理后续题目（如回文链表、环形链表等），欢迎随时告诉我！💪
