### 单题精析：[268] 丢失的数字 —— 多范式解法与算法思维映射  

> **题目描述**：给定一个包含 `n` 个不同整数的数组 `nums`，其中每个整数都在 `[0, n]` 范围内，恰好缺失一个数字。请找出该缺失数字。  
> **核心抽象**：在完整集合 `{0, 1, ..., n}` 中识别唯一未出现的元素。

---

#### 🧩 四种主流解法对比

| 解法        | 核心机制                     | 时间复杂度   | 空间复杂度   | 适用场景                     |
|-------------|----------------------------|--------------|--------------|------------------------------|
| 排序扫描     | 利用索引与值的一致性         | O(n log n)   | O(1)         | 快速实现、输入近有序         |
| 哈希集合     | 显式记录存在性                | O(n)         | O(n)         | 通用、可扩展至多缺失         |
| 数学求和     | 高斯公式 + 差值               | O(n)         | O(1)         | 代码简洁、常数快             |
| 位运算法     | 异或自反律实现成对抵消        | O(n)         | O(1)         | 无溢出、位级原生、最优雅     |

---

#### 🔍 解法详解与代码实现

##### 1. **排序扫描法（直观起点）**
```cpp
int missingNumber(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); ++i)
        if (nums[i] != i) return i;
    return nums.size(); // 缺失最大值 n
}
```
- **原理**：排序后，若无缺失，则 `nums[i] == i`。
- **特点**：逻辑清晰，但时间非最优；适合快速验证思路。

##### 2. **哈希集合法（存在性查询）**
```cpp
int missingMatrix(vector<int>& nums) {
    unordered_set<int> seen(nums.begin(), nums.end());
    for (int i = 0; i <= nums.size(); ++i)
        if (!seen.count(i)) return i;
    return -1; // 不可达
}
```
- **原理**：构建全集 `{0..n}` 与 `nums` 的差集。
- **注意**：使用 `unordered_set` 而非 `set` 以避免 O(log n) 插入开销。
- **优势**：天然支持“多个缺失”或“动态查询”扩展。

##### 3. **数学求和法（代数压缩）**
```cpp
int missingNumber(vector<int>& nums) {
    int n = nums.size();
    long total = (long)n * (n + 1) / 2; // 防溢出
    for (int x : nums) total -= x;
    return (int)total;
}
```
- **原理**：缺失值 = 理论总和 − 实际总和。
- **关键点**：使用 `long` 避免 `n*(n+1)` 溢出（虽 LeetCode 测试用例通常安全，但工程中应防御）。
- **哲学**：用全局代数性质替代逐元素比较。

##### 4. **位运算法（极致优雅）**
```cpp
int missingNumber(vector<int>& nums) {
    int res = 0;
    for (int x : nums) res ^= x;           // 异或所有数组元素
    for (int i = 0; i <= nums.size(); ++i) // 异或 0 到 n
        res ^= i;
    return res;
}
```
- **原理**：  
  - 所有在 `nums` 和 `[0, n]` 中都出现的数被异或两次 → 抵消为 0；  
  - 唯一缺失的数只出现一次 → 保留在 `res` 中。
- **优势**：
  - 无符号/溢出问题；
  - 完全位操作，O(1) 空间；
  - 与 [136] 只出现一次的数字 同源，体现范式复用。

---

#### 🧠 认知升维：从解法到思维范式

- **问题识别信号**：
  - “0 到 n”、“唯一缺失”、“无重复” → 触发 **异或 / 求和** 思维；
  - “快速查找” → 考虑 **哈希**；
  - “允许 O(n log n)” → **排序** 是合理入口。

- **工程决策原则**：
  - **优先位运算**：当满足“唯一缺失 + 整数范围”时，它是时空最优且鲁棒的选择；
  - **慎用数学法**：需评估整数溢出风险（尤其在嵌入式或大数场景）；
  - **哈希为通用兜底**：当问题变体（如多缺失、非连续）出现时，哈希最具弹性。

- **面试表达建议**：
  > “我首先想到排序法，但意识到它不是最优。接着考虑哈希，但空间不理想。最终，利用异或的自反性，可以在 O(n) 时间和 O(1) 空间内解决——这正是本题最优雅的解法。”

---

#### ✅ 总结

[268] 表面简单，实则是一道**算法思维的微缩景观**：  
- **排序**代表直觉；  
- **哈希**代表通用工具；  
- **数学**代表代数洞察；  
- **位运算**代表底层抽象。  

> 正如初级算法专题的收官之作，它提醒我们：  
> **真正的掌握，不是会写一种解法，而是理解为何有四种解法，以及何时用哪一种。**

---  
