
---

# [461] 汉明距离（Hamming Distance）

## 🔍 题目本质
> **计算两个整数在二进制表示下对应位不同的数量**。  
> 核心洞察：**异或（XOR）天然刻画“差异”** —— `x ^ y` 的结果中，`1` 的位置即为两数不同的位。

因此，问题转化为：**统计 `x ^ y` 的二进制中 `1` 的个数（即“汉明重量”）**。

---

## ✅ 解法对比

### 1. **内置函数法（GCC 扩展）**
```cpp
return __builtin_popcount(x ^ y);
```
- **优点**：一行解决，底层由 CPU 指令（如 `POPCNT`）加速，效率极高。
- **局限**：非标准 C++，依赖编译器（GCC/Clang 支持，MSVC 需用 `__popcnt`）。
- **适用场景**：竞赛、性能敏感且环境可控的场合。

---

### 2. **逐位检查法**
```cpp
int s = x ^ y, res = 0;
while (s) {
    res += s & 1;   // 检查最低位是否为 1
    s >>= 1;        // 逻辑右移（因 s 为 int，需注意符号位？）
}
```
- **潜在问题**：若 `s` 为负数（如 `x=0, y=-1`），`s >> 1` 是**算术右移**（高位补 1），导致死循环！
- **修正建议**：应将 `s` 声明为 `unsigned int` 或使用 `uint32_t` 确保逻辑右移。
- **复杂度**：固定 32 次循环（对 32 位整数），O(1) 时间，但常数较大。

---

### 3. **Brian Kernighan 算法（推荐）✅**
```cpp
int s = x ^ y, res = 0;
while (s) {
    s &= s - 1;  // 清除最右边的 1
    res++;
}
```
- **核心原理**：  
  `s - 1` 会将 `s` 最右边的 `1` 及其后所有 `0` 翻转；  
  `s & (s - 1)` 则精准清除该 `1`，其余位不变。
- **优势**：
  - 循环次数 = `1` 的个数（k），时间复杂度 O(k)，对稀疏二进制数极高效；
  - 无符号/有符号均安全（因 `s = x ^ y` 在 `int` 范围内，且操作基于位模式）；
  - 代码简洁，体现位运算结构性思维。
- **典型应用**：位计数、判断 2 的幂（`n > 0 && (n & (n-1)) == 0`）。

---

## 🧠 关键认知

| 维度 | 启示 |
|------|------|
| **问题转化** | 汉明距离 → 异或 → 汉明重量，体现“**差异建模**”思想 |
| **位运算哲学** | 优秀位操作不逐位扫描，而**利用二进制代数性质批量处理** |
| **算法选择** | 优先考虑 **Kernighan 算法**：平衡效率、可移植性与表达力 |
| **边界意识** | 使用右移时务必确认数据类型（无符号 vs 有符号） |

---

## 💡 延伸思考
- 若输入为 `uint64_t`，Kernighan 算法依然适用；
- 在硬件层面，现代 CPU 的 `POPCNT` 指令可在 1 周期内完成计数，但 Kernighan 在无硬件支持时仍是最佳软件方案；
- 此技巧可推广至：**快速检测两状态是否仅一位不同**（`(x ^ y) & ((x ^ y) - 1) == 0`）。

---

> **总结**：汉明距离是位运算的“启蒙题”，其最优解（Kernighan 算法）以极简代码揭示了二进制结构之美——**不是暴力枚举，而是与数字本身对话**。

---
