
---

### 📌 [190] 颠倒二进制位（Reverse Bits）

> **题目要求**：给定一个 32 位无符号整数 `n`，返回其二进制位顺序反转后的结果（仍为 32 位无符号整数）。

---

#### ✅ 解法一：`bitset` + 字符串反转（直观但非原生）

```cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        bitset<32> b(n);
        string s = b.to_string();      // 转为 "000...1010" 形式
        reverse(s.begin(), s.end());   // 反转字符串
        bitset<32> rev(s);             // 从反转字符串构造新 bitset
        return rev.to_ulong();
    }
};
```

- **优点**：逻辑清晰，易于理解。
- **缺点**：
  - 引入 **字符串中间表示**，额外 O(32) 空间；
  - 涉及多次类型转换（int → bitset → string → bitset → int）；
  - **未在位域内原生操作**，违背位运算问题的最佳实践；
  - 性能开销高于纯位操作（LeetCode 实测慢约 2~3 倍）。

> 💡 适用于快速验证思路，但**不推荐作为最终解法**。

---

#### ✅✅ 解法二：逐位提取 + 位重组（高效原生解法）

```cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for (int i = 0; i < 32; ++i) {
            res = (res << 1) | (n & 1);  // 提取 n 最低位，拼接到 res
            n >>= 1;                     // 右移丢弃已处理位
        }
        return res;
    }
};
```

##### 🔍 核心三要素（位重组范式）：
| 步骤 | 操作 | 作用 |
|------|------|------|
| **1. 提取** | `n & 1` | 获取 `n` 当前最低位（0 或 1） |
| **2. 腾挪** | `res << 1` | 将已构建的 `res` 左移，**最低位变为 0**（腾出写入位置） |
| **3. 拼接** | `|` | 因目标位为 0，`0 \| x = x`，实现**安全写入** |

##### ⚙️ 关键性质：
- **左移 = ×2（无溢出时）**，**右移 = ÷2 向下取整**（对无符号数成立）；
- **`|` 的写入有效性依赖目标位为 0** —— 由 `res << 1` 保证；
- 循环固定 32 次，时间复杂度 **O(1)**，空间 **O(1)**，无额外分配。

> ✅ 此解法体现 **“位即数据流”** 的思维：将 `n` 视为输入位流，`res` 为反向输出缓冲区。

---

#### 🧠 对比与启示

| 维度 | `bitset` + string | 位重组 |
|------|-------------------|--------|
| **抽象层级** | 高（字符级） | 低（位级） |
| **是否原生** | ❌ 降维处理 | ✅ 位域闭环 |
| **性能** | 较慢（内存+转换开销） | 极快（仅寄存器操作） |
| **可迁移性** | 仅适用于小规模固定位宽 | 通用位操作模板 |
| **工程价值** | 快速原型 | 生产级代码 |

> 🌟 **核心洞见**：  
> **位运算问题应避免“转字符串”这类降维解法**。真正的优雅在于利用二进制代数结构（如 `n & 1`、`<<`、`|`）直接建模位流行为。

---

#### 🔚 总结一句话：
> **反转二进制位 = 从右到左读 `n`，从左到右写 `res`，通过“提取-腾挪-拼接”三步完成位流重定向。**

---

#### 📚 延伸思考
- 若需反转 **64 位** 整数？只需改循环次数为 64。
- 能否用 **分治法**（如先交换高低 16 位，再递归）实现 O(log n)？可以，但常数大，32 位场景无优势。
- 此模式可迁移到：**位镜像、位掩码生成、自定义位打包/解包**等系统编程场景。

---

> 📝 **个人备注**：初学时倾向 `bitset` 是自然的，但掌握位重组范式后，应主动在位域内思考——这是从“会做题”到“懂底层”的关键跃迁。

--- 

