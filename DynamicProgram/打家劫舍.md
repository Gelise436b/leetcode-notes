
---

### 📝 [198] 打家劫舍 —— 互斥决策下的最优子结构

#### 🔍 题目核心
> 给定一排房屋，每间有非负金额 `nums[i]`。若偷相邻两间会触发警报，求能偷到的最大金额。

**关键约束**：**不能选择相邻元素** → 决策具有**路径依赖性与互斥性**。

---

#### 💡 正确解法：动态规划（DP）

##### ✅ 状态定义（核心！）
- 定义 `dp[i]` 为：**考虑前 `i+1` 间房屋（即 `nums[0..i]`）时，能获得的最大金额**。
- 注意：**不要求必须偷第 `i` 间**，只关心“到此为止”的最优解。

##### ✅ 状态转移方程
对第 `i` 间房屋，有两种选择：
1. **不偷** → 最大金额 = `dp[i-1]`
2. **偷** → 则不能偷 `i-1`，最大金额 = `dp[i-2] + nums[i]`

因此：
```cpp
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

##### ✅ 边界条件
- `dp[0] = nums[0]`（只有一间，必偷）
- `dp[1] = max(nums[0], nums[1])`（两间选较大者）

##### ✅ 空间优化（滚动变量）
由于 `dp[i]` 仅依赖前两项，可用两个变量代替数组：
```cpp
int prev2 = 0, prev1 = 0;
for (int x : nums) {
    int cur = max(prev1, prev2 + x);
    prev2 = prev1;
    prev1 = cur;
}
return prev1;
```

##### ✅ 递归 + 记忆化（Top-down，C++23 递归 lambda）
```cpp
vector<int> memo(n, -1);
auto dfs = [&](this auto&& dfs, int i) -> int {
    if (i < 0) return 0;
    if (memo[i] != -1) return memo[i];
    return memo[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);
};
return dfs(n - 1);
```
> **语法说明**：`this auto&& dfs` 是 C++23 显式对象参数语法，使 lambda 可自递归；`auto&&` 为万能引用，支持高效传参。

---

#### ⚠️ 常见误区与反思

| 误区 | 正确认知 |
|------|--------|
| **试图暴力枚举所有合法子集**（如回溯） | 指数级复杂度（O(2ⁿ)），无法通过大规模用例；**DP 的核心价值是消除重复子问题** |
| **定义 `dp[i]` 为“偷第 `i` 间时的最大金额”** | 虽可行，但最终答案需遍历 `dp` 取最大值，不如“考虑前 i 间”的定义自然 |
| **忽略“不偷当前”的选项** | 错误写成 `dp[i] = dp[i-2] + nums[i]`，遗漏了继承前一状态的可能性 |
| **面对清晰描述仍想不到 DP** | 需建立条件反射：**“多阶段选择 + 局部决策影响全局 + 子问题重叠” → 优先考虑 DP** |

---

#### 🧠 范式提炼：互斥型 DP 模型

| 特征 | 应对策略 |
|------|--------|
| **相邻元素不可同时选** | 状态转移跳过前一项（`i-2`） |
| **当前决策依赖前 k 步** | 使用滚动变量压缩空间至 O(1) |
| **问题具“无后效性”** | 当前最优解仅由历史最优决定，无需记录完整路径 |

> ✅ **本题是“打家劫舍”系列的基石**，后续变体（环形房屋、树形结构）均在此模型上扩展约束。

---

#### 🔗 关联题目
- [213] 打家劫舍 II（房屋成环 → 拆分为两个线性问题）
- [337] 打家劫舍 III（房屋成树 → 树形 DP）

---

#### 📌 总结
> **打家劫舍的本质不是“偷哪家”，而是“在互斥约束下如何组合历史最优解”。**  
> 通过精准的状态定义，将“不能相邻”的硬约束转化为 `dp[i-2]` 的自然回退，体现了 DP **以状态封装约束、以转移实现决策** 的强大抽象能力。今后遇类似“互斥选择”场景，应立即联想此范式。

---

