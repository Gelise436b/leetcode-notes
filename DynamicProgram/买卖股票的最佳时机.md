

---

### 📌 LeetCode [121] 买卖股票的最佳时机 —— 贪心视角下的极值优化

#### 🔍 问题简述
给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。  
你**只能完成一次交易**（即买入一次 + 卖出一次，且买入必须在卖出之前）。  
求所能获得的**最大利润**。

> 示例：`prices = [7,1,5,3,6,4]` → 最佳在第 2 天买入（1），第 5 天卖出（6），利润 = 5。

---

### ✅ 核心思路：**分离“成本”与“收益”，动态维护历史最优**

关键洞察：  
> **最大利润 = 当前价格 - 历史最低价格**  

因此，无需枚举所有买卖组合，只需在遍历过程中：
- 实时记录**到目前为止的最低价格**（`minprice`）
- 计算**以当前价格卖出能获得的最大利润**（`p - minprice`）
- 更新全局最大利润（`ans`）

---

### 🧠 正确解法（贪心 + 一次遍历）✅
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int minprice = prices[0];               // 初始化为第一天价格
        for (int p : prices) {
            ans = max(ans, p - minprice);       // 尝试在今天卖出
            minprice = min(minprice, p);        // 更新历史最低买入价
        }
        return ans;
    }
};
```

- **时间复杂度**：O(n) —— 仅一次遍历  
- **空间复杂度**：O(1) —— 仅用两个变量  
- **正确性保证**：  
  - `minprice` 始终是 `p` 之前的最小值（因先计算利润，再更新 `minprice`）  
  - 即使 `minprice` 在最后一天更新，也不会影响 `ans`（因为之后无卖出机会）

---

### ❌ 常见误区反思

| 错误思路 | 问题所在 |
|--------|--------|
| 枚举所有 `(i, j)` 对（i < j） | 时间复杂度 O(n²)，大输入超时 |
| 先找最小值再找其后最大值 | 若最小值出现在最后，则无法交易；未考虑“顺序约束” |
| 试图用完整 DP 数组记录每天状态 | 过度设计；本题无状态依赖链，贪心即可 |

> 💡 **顿悟点**：最大利润**与具体哪天买卖无关**，只取决于“最低成本”和“最高溢价”的时序组合。

---

### 💡 思维升维：贪心 vs 动态规划

虽然本题常被归入 DP 专题，但其本质是**贪心策略的成功应用**：
- **DP 视角**：可定义 `dp[i][0/1]` 表示第 `i` 天持有/不持有股票的最大利润，但状态转移退化为简单极值维护；
- **贪心视角**：因**只允许一次交易**，全局最优 = 每一步局部最优（用当前价减历史最低价）；

> ✅ **判断标准**：若子问题最优解可由**单一时序极值**直接导出，优先考虑贪心。

---

### 📚 学习价值

| 维度 | 启示 |
|------|------|
| **问题抽象** | 将“买卖决策”转化为“价格差极值”问题 |
| **算法选择** | “有序序列 + 单次操作 + 极值目标” → 贪心 + 一次遍历 |
| **工程实践** | 避免冗余计算，用 O(1) 空间解决看似需 O(n²) 的问题 |
| **后续延伸** | 为 [122]（多次交易）、[123]（两次交易）等复杂股票问题打下基础 |

---

### ✅ 掌握建议
- 能手写上述代码，并解释为何**先更新 `ans` 再更新 `minprice`**  
- 能口述：“为什么这不是 DP？什么时候需要用 DP？”  
- 能推广到类似问题：如“最大差值（后减前）”、“温度上升最大跨度”等

---
