
---

### 📌 LeetCode [70] 爬楼梯 —— 动态规划入门经典

#### 🔍 问题简述
你正在爬一个有 `n` 阶的楼梯，每次可以爬 **1 阶或 2 阶**。问：有多少种不同的方法可以到达楼顶？

> 本质：求斐波那契数列第 `n+1` 项（`f(0)=1, f(1)=1, f(2)=2, ...`）

---

### ✅ 解法演进：从暴力递归到空间优化 DP

#### 1️⃣ 方法一：纯递归（超时 ❌）
```cpp
class Solution {
    int dfs(int n) {
        if (n <= 1) return 1;
        return dfs(n - 1) + dfs(n - 2);
    }
public:
    int climbStairs(int n) {
        return dfs(n);
    }
};
```
- **时间复杂度**：O(2ⁿ) —— 存在大量重复子问题  
- **空间复杂度**：O(n) —— 递归栈深度  
- **问题**：指数级爆炸，无法通过大 `n` 测试用例。

---

#### 2️⃣ 方法二：记忆化搜索（递归 + 缓存）✅
```cpp
class Solution {
    vector<int> memo;
    int dfs(int n) {
        if (n <= 1) return 1;
        int& res = memo[n];
        if (res) return res;               // 已计算则直接返回
        return res = dfs(n - 1) + dfs(n - 2);
    }
public:
    int climbStairs(int n) {
        memo.resize(n + 1);                // 分配 n+1 空间，索引 0~n
        return dfs(n);
    }
};
```
- **思想**：Top-down DP，用 `memo` 缓存已计算状态，避免重复递归  
- **时间复杂度**：O(n)  
- **空间复杂度**：O(n)（缓存数组 + 递归栈）  
- **关键点**：`memo.resize(n + 1)` 确保 `memo[n]` 可安全访问

---

#### 3️⃣ 方法三：递推法（Bottom-up DP）✅
```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> f(n + 1);
        f[0] = f[1] = 1;
        for (int i = 2; i <= n; ++i) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```
- **思想**：自底向上填表，消除递归开销  
- **时间复杂度**：O(n)  
- **空间复杂度**：O(n)  
- **优势**：无函数调用栈，更稳定；逻辑线性清晰

---

#### 4️⃣ 方法四：空间优化（滚动变量）🌟 最优解
```cpp
class Solution {
public:
    int climbStairs(int n) {
        int f0 = 1, f1 = 1;               // f0 = f[i-2], f1 = f[i-1]
        for (int i = 2; i <= n; ++i) {
            int new_f = f0 + f1;          // f[i] = f[i-1] + f[i-2]
            f0 = f1;                      // 滚动更新
            f1 = new_f;
        }
        return f1;
    }
};
```
- **思想**：观察到 `f[i]` 仅依赖前两项，无需保存整个数组  
- **时间复杂度**：O(n)  
- **空间复杂度**：O(1)  
- **工程意义**：体现“状态压缩”思想，是 DP 优化的典型范式

---

### 💡 核心认知提炼

| 维度 | 关键洞察 |
|------|--------|
| **问题本质** | 斐波那契数列变体，具有最优子结构与无后效性 |
| **DP 建模** | 状态 `dp[i]` = 到达第 `i` 阶的方法数；转移方程 `dp[i] = dp[i-1] + dp[i-2]` |
| **优化路径** | 递归 → 记忆化 → 迭代 DP → 空间压缩 |
| **通用启示** | 若状态仅依赖常数个历史值，必可空间优化至 O(1) |

---

### 📚 学习价值
- 是理解 **动态规划三大要素**（状态定义、转移方程、边界条件）的最佳入门题  
- 展示了 **算法优化的完整链条**：从正确性 → 效率 → 空间极致利用  
- 为后续如「打家劫舍」「股票问题」等序列型 DP 奠定思维基础

> ✅ **建议掌握程度**：能手写方法四（空间优化版），并口述四种方法的演进逻辑与复杂度差异。

---
