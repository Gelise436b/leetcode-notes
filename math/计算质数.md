
---

### 📘 题目：[204] 计数质数（Count Primes）

#### ✅ 核心思想  
使用 **埃拉托斯特尼筛法**（Sieve of Eratosthenes）高效统计小于 `n` 的质数个数。  
**关键洞察**：不逐个判断每个数是否为质数，而是**从最小质数开始，批量标记其倍数为合数**，从而避免重复无效计算。

---

#### 🔧 算法步骤
1. 创建布尔数组 `signal[0..n-1]`，初始化为 `true`（假设所有数都是质数）；
2. 从 `i = 2` 开始遍历到 `n - 1`：
   - 若 `signal[i] == true`，说明 `i` 是质数 → `count++`；
   - 将 `i` 的所有倍数（从 `2*i` 起）标记为 `false`（即合数）；
3. 返回最终计数 `count`。

> 💡 **优化提示**：内层循环可从 `j = i * i` 开始（而非 `2*i`），因为小于 `i²` 的 `i` 的倍数已被更小的质数标记过。但你的当前实现从 `i + i` 起标，逻辑正确，仅稍有冗余。

---

#### 📌 代码实现（你的版本）
```cpp
class Solution {
public:
    int countPrimes(int n) {
        if (n <= 2) return 0; // 可加此边界提速
        vector<bool> signal(n, true);
        int count = 0;
        for (int i = 2; i < n; ++i) {
            if (signal[i]) {
                ++count;
                for (int j = i + i; j < n; j += i) {
                    signal[j] = false;
                }
            }
        }
        return count;
    }
};
```

---

#### ⏱️ 复杂度分析
- **时间复杂度**：$O(n \log \log n)$ —— 筛法经典复杂度，远优于暴力 $O(n\sqrt{n})$；
- **空间复杂度**：$O(n)$ —— 用于存储标记数组；

---

#### 🧠 学习要点总结
| 维度 | 内容 |
|------|------|
| **思维跃迁** | 从“验证每个数” → “生成并排除合数”，体现**逆向构造**的算法智慧 |
| **数学依据** | 每个合数必有最小质因数 ⇒ 只需用质数去筛，且从 $p^2$ 起筛无遗漏 |
| **工程细节** | `vector<bool>` 是空间特化容器（位压缩），实际内存约为 $n/8$ 字节 |
| **常见误区** | 忘记 `0` 和 `1` 非质数（你的代码因从 `i=2` 开始，天然规避） |

---

#### 🔁 改进建议（进阶）
```cpp
// 优化版：从 i*i 开始标记 + 外层循环至 sqrt(n)
int countPrimes(int n) {
    if (n <= 2) return 0;
    vector<bool> isPrime(n, true);
    int count = 0;
    for (int i = 2; i < n; ++i) {
        if (isPrime[i]) {
            ++count;
            if ((long long)i * i < n) { // 防溢出
                for (int j = i * i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
    }
    return count;
}
```

---

#### 🔗 关联知识
- 后续可拓展：**线性筛**（欧拉筛）—— 每个合数仅被最小质因数筛一次，达 $O(n)$；
- 应用场景：密码学、哈希表容量选择、数学竞赛中的质数预处理。

---

> ✅ **一句话心得**：  
> “筛法不是更快地判断质数，而是聪明地不去判断合数。”

---
