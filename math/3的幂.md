
---

### 📘 题目：[326] 3 的幂（Power of Three）

#### ✅ 核心目标  
判断给定整数 `n` 是否为 3 的整数次幂（即是否存在非负整数 `k`，使得 $ n = 3^k $）。

---

### 🔧 解法一：递归（通用方法）

#### 思路
不断将 `n` 除以 3，直到：
- 剩余为 1 → 是 3 的幂；
- 出现不能被 3 整除的数，或 `n ≤ 0` → 不是。

#### 关键边界处理
- **必须显式排除 `n <= 0`**：3 的幂恒为正整数；
- **基线情形 `n == 1`**：对应 $ 3^0 = 1 $，是合法幂。

#### 你的代码（已修正）
```cpp
class Solution {
public:
    bool iFreal(int n) {
        if (n == 1) return true;
        if (n <= 0 || n % 3 != 0) return false;
        return iFreal(n / 3);
    }

    bool isPowerOfThree(int n) {
        return iFreal(n);
    }
};
```

#### ⏱️ 复杂度
- **时间**：$O(\log_3 n)$ —— 每次除以 3；
- **空间**：$O(\log_3 n)$ —— 递归栈深度；

> 💡 **教训**：初版因遗漏 `n <= 0` 导致 `n=0` 时无限递归 → **递归设计必须优先处理非法输入与终止条件**。

---

### 🔧 解法二：大幂整除（数学巧解）

#### 思路
在 32 位有符号整数范围内，**最大的 3 的幂是**：
\[
3^{19} = 1162261467 < 2^{31} - 1
\]
由于 3 是**质数**，其所有幂 $3^k$（$k \leq 19$）都是 $3^{19}$ 的**因数**，且 $3^{19}$ 的**所有正因数都是 3 的幂**。

因此：
> $n$ 是 3 的幂 ⇔ $n > 0$ 且 $1162261467 \bmod n == 0$

#### 代码实现
```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
};
```

#### ⏱️ 复杂度
- **时间**：$O(1)$
- **空间**：$O(1)$

#### ⚠️ 适用条件（重要！）
- **底数必须是质数**（如 2、3、5），否则因数可能混入其他质因子（如 6 的因数 12 不是 6 的幂）；
- **依赖固定整数范围**（如 `int` 最大值），不适用于任意精度场景。

---

### 🧠 学习要点总结

| 维度 | 内容 |
|------|------|
| **递归设计原则** | 先处理非法输入（`n ≤ 0`），再定义基线（`n == 1`），最后递推 |
| **数学性质利用** | 质数幂的因数封闭性 → 可用最大幂整除判定 |
| **方法对比** | 递归：通用、可读性强；大幂整除：高效但特化 |
| **常见误区** | 误以为“大幂整除”适用于任意底数（如 4、6）→ 实则仅限质数 |

---

### 🔗 关联拓展
- 类似技巧可用于 [231. 2 的幂]：`(1 << 30) % n == 0`；
- 若底数非质数（如 4），需改用循环或对数（注意浮点精度）；
- 在密码学或哈希中，此类性质常用于快速合法性校验。

---

> ✅ **一句话心得**：  
> “递归教会我严谨处理边界，数学教我看穿问题本质——二者互补，方得完整解法。”

---
