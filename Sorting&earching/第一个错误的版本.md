
---

# [278] 第一个错误的版本

## 📌 题目描述
- 版本 `1` 到 `n` 中，从某个版本开始**所有后续版本都是错误的**；
- 提供 API：`bool isBadVersion(version)`，返回该版本是否错误；
- 要求：**找出第一个错误的版本**；
- 限制：调用 `isBadVersion` 的次数尽可能少（即不能暴力线性扫描）。

---

## ❌ 初始错误思路（需警惕）
> “从 1 开始逐个调用 `isBadVersion`，直到找到第一个错误版本”

- **问题**：时间复杂度 O(n)，在 `n` 极大时**必然超时**；
- **根本原因**：忽略了题目隐含的**单调性**：
  - 若 `isBadVersion(k) == true`，则对所有 `x ≥ k`，都有 `isBadVersion(x) == true`；
  - 这是典型的 **“有序 + 查找边界”** 场景 ⇒ **必须使用二分查找**！

---

## ✅ 正确解法：二分查找（左边界模型）

### 🔑 核心思想
- 在 `[1, n]` 范围内，寻找**第一个满足 `isBadVersion(v) == true` 的位置**；
- 这是经典的 **“左边界二分”** 问题。

### 🔄 二分逻辑
| 条件 | 操作 | 说明 |
|------|------|------|
| `isBadVersion(mid) == true` | `j = mid - 1` | 当前是坏版本，但可能不是第一个，继续向左找 |
| `isBadVersion(mid) == false` | `i = mid + 1` | 当前是好版本，第一个坏版本一定在右边 |

### 🎯 循环结束时
- `i` 恰好指向**第一个坏版本**；
- 因为 `i` 始终是“第一个可能为坏版本”的位置（循环不变式）。

### 💡 防溢出技巧
```cpp
int m = i + (j - i) / 2;  // 等价于 (i + j) / 2，但避免整数溢出
```

---

## 🧠 学习收获

1. **识别二分场景的关键**：  
   - 数据具有**单调性**（如：好 → 坏，0 → 1，false → true）；  
   - 要求找**第一个/最后一个满足条件的位置**。
2. **左边界二分模板**（牢记）：
   ```cpp
   int left = 1, right = n;
   while (left <= right) {
       int mid = left + (right - left) / 2;
       if (condition(mid)) {
           right = mid - 1;   // 向左收缩
       } else {
           left = mid + 1;    // 向右收缩
       }
   }
   return left;  // left 即为第一个满足 condition 的位置
   ```
3. **API 调用成本意识**：题目限制调用次数，本质是要求 **O(log n)** 解法。

---

## ✍️ 默写模板（推荐记忆）

```cpp
int firstBadVersion(int n) {
    int i = 1, j = n;
    while (i <= j) {
        int m = i + (j - i) / 2;
        if (isBadVersion(m)) {
            j = m - 1;      // 坏版本，往左找更早的
        } else {
            i = m + 1;      // 好版本，往右找第一个坏的
        }
    }
    return i;  // i 是第一个坏版本
}
```

---

## 📎 关联题型（巩固二分边界思维）
- [35] 搜索插入位置（找 >= target 的第一个位置）
- [34] 在排序数组中查找元素的第一个和最后一个位置
- [69] x 的平方根（找满足 x² ≤ n 的最大 x）

> 💡 所有这些题的核心都是：**在有序序列中找满足某条件的边界位置**。

---
