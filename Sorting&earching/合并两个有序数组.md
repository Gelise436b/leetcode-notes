
---

# [88] 合并两个有序数组

## 📌 题目要求
- 给定两个**非递减排序**的整数数组 `nums1` 和 `nums2`；
- 将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个**非递减有序数组**；
- `nums1` 的长度为 `m + n`，其中前 `m` 个元素有效，后 `n` 个位置为 0（预留空间）；
- **必须原地修改 `nums1`，不使用额外数组**。

---

## ❌ 初始错误思路（需避免）
> “先合并到新数组，再拷贝回 `nums1`”

- **问题**：违反“原地操作”要求，空间复杂度 O(m+n)，不符合题目约束；
- **本质误区**：未利用 `nums1` 末尾的**预留空位**这一关键条件。

---

## ✅ 正确解法：逆向双指针（从后往前填充）

### 🔑 核心思想
- 正向合并会**覆盖 `nums1` 中尚未处理的元素**；
- 但 `nums1` 末尾有 `n` 个空位 ⇒ **从后往前填，安全无覆盖**；
- 比较两个数组当前最大值，将较大者放入 `nums1` 末尾。

### 🧩 指针设置
| 指针 | 含义 |
|------|------|
| `p1 = m - 1` | 指向 `nums1` 有效部分的最后一个元素 |
| `p2 = n - 1` | 指向 `nums2` 的最后一个元素 |
| `p = m + n - 1` | 指向 `nums1` 的最终末尾（待填位置） |

### 🔄 循环条件
```cpp
while (p2 >= 0)  // 只要 nums2 还有元素未合并，就继续
```
- 若 `nums1` 先耗尽（`p1 < 0`），剩余 `nums2` 直接填入即可；
- 若 `nums2` 先耗尽，循环结束，`nums1` 剩余部分已在正确位置。

### 💡 关键判断
```cpp
if (p1 >= 0 && nums1[p1] > nums2[p2])
    nums1[p--] = nums1[p1--];
else
    nums1[p--] = nums2[p2--];
```
- 注意先检查 `p1 >= 0`，防止越界；
- “否则”包含两种情况：`nums2[p2] ≥ nums1[p1]` 或 `p1 已耗尽`。

---

## 🧠 学习收获

1. **空间复用意识**：当目标容器有预留空间时，**逆序操作**可避免数据覆盖；
2. **双指针方向选择**：  
   - 正向：适用于结果独立于原数据（如去重、移动零）；  
   - **逆向**：适用于**原地合并/插入**且有尾部空间；
3. **边界简化技巧**：以 `p2 >= 0` 为循环终止条件，天然处理了 `nums1` 先结束的情况；
4. **算法复杂度**：时间 O(m+n)，空间 O(1)，达到理论最优。

---

## ✍️ 默写模板（推荐记忆）

```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int p1 = m - 1, p2 = n - 1, p = m + n - 1;
    while (p2 >= 0) {
        if (p1 >= 0 && nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
}
```

---

## 📎 关联题型
- [21] 合并两个有序链表（正向双指针，无需考虑覆盖）
- [977] 有序数组的平方（双指针从两端向中间）

> 💡 **核心区别**：数组原地操作需警惕覆盖，链表无此问题。

---
